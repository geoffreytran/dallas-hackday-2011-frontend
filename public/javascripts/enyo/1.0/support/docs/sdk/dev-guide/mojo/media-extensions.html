<!DOCTYPE html>
<html>
	<head>
		<title>$if(pagetitle)$$pagetitle$$endif$</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<link rel="stylesheet" href="_css/chrome.css" />
		<link rel="stylesheet" href="../_css/chrome.css" />
		<link rel="stylesheet" href="../../_css/chrome.css" />
		<link rel="stylesheet" href="../../../_css/chrome.css" />
		<script src="_js/jquery-1.4.2.min.js" type="text/javascript"></script>
		<script src="../_js/jquery-1.4.2.min.js" type="text/javascript"></script>
		<script src="../../_js/jquery-1.4.2.min.js" type="text/javascript"></script>
		<script src="../../../_js/jquery-1.4.2.min.js" type="text/javascript"></script>
		<script src="_js/doc.js" type="text/javascript"></script>
		<script src="../_js/doc.js" type="text/javascript"></script>
		<script src="../../_js/doc.js" type="text/javascript"></script>
		<script src="../../../_js/doc.js" type="text/javascript"></script>
	</head>
	<body>
		<div id="content">
    
    <h1 id="media-extensions">
      Media Extensions
    </h1>
    <p>
      <strong>Important:</strong>
    </p>
    <p>
      This page describes an API that has been deprecated as of webOS 1.4 and will eventually be removed. For information on the current API, refer to the <a href="/dev-guide/mojo/audio.html">Audio</a> and <a href="/dev-guide/mojo/video.html">Video</a> doc pages.
    </p>
    <h2 id="overview">
      Overview
    </h2>
    <p>
      To support non-standard features, webOS has added extensions to HTML5 media objects, including mnemonics for several structures and values defined in HTML5, plus a .palm sub-object to the Audio and Video objects for webOS-specific features.
    </p>
    <h2 id="media-events">
      Media Events
    </h2>
    <p>
      These events are generated by HTMLMediaElement instances.
    </p>
    <p>
      Applications must explicitly register event handlers to receive them, which is standard with HTML events. At any time after creating an Audio or Video object, the normal <code>addEventListener(event, callback)</code> call is used to register for an event.
    </p>
    <p>
      <strong>Note:</strong>
    </p>
    <p>
      The third parameter to <code>addEventListener</code> is currently ignored for HTMLMediaElement objects.
    </p>
    <table border="0">
      <tbody>
        <tr>
          <th>
            Javascript define
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            Media.Event.ABORT
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.CANPLAY
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.CANPLAYTHROUGH
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.CANSHOWFIRSTFRAME
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.DURATIONCHANGE
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.EMPTIED
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.ENDED
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.ERROR
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.LOAD
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.LOADEDFIRSTFRAME
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.LOADEDMETADATA
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.LOADSTART
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.PAUSE
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.PLAY
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.PROGRESS
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.SEEKED
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.SEEKING
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.STALLED
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.TIMEUPDATE
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.WAITING
          </td>
          <td>
            Corresponds to HTMLMediaElement event of the same name.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.X_PALM_CONNECT
          </td>
          <td>
            The JavaScript library has connected to the media process and is ready for commands.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.X_PALM_DISCONNECT
          </td>
          <td>
            The JavaScript library has disconnected from the media process (probably due to error).
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.X_PALM_RENDER_MODE
          </td>
          <td>
            Notification that the render mode (video sink) has changed.
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.X_PALM_SUCCESS
          </td>
          <td>
            Low-level notification that the message sent to the media process succeeded (not normally used by applications).
          </td>
        </tr>
        <tr>
          <td>
            Media.Event.X_PALM_WATCHDOG
          </td>
          <td>
            No response was received from the media process for a prolonged time (error condition).
          </td>
        </tr>
      </tbody>
    </table>
    <h2 id="palm-specific-events">
      Palm-Specific Events
    </h2>
    <p>
      The preceding events with the <code>&quot;X_PALM_&quot;</code> prefix are Palm extensions to the normal HTMLMediaElement event list. The connect, disconnect, and watchdog events are important for correct operation and error handling.
    </p>
    <p>
      This section discusses the following events:
    </p>
    <ul>
      <li>Connect
      </li>
      <li>Disconnect/Watchdog
      </li>
    </ul>
    <h3 id="connect-event">
      Connect Event
    </h3>
    <p>
      The connect event is sent after establishing the connection to the mediaserver. Applications must not try to play media or set the .src of an audio object until after receiving this event because if the object is not associated with the mediaserver before attempting this the commands may be lost. It is acceptable to call <code>addEventListener()</code> before receiving the connect, but applications cannot do anything else.
    </p>
    <p>
      Example of connect callback:
    </p>
    <blockquote>
      <pre>
<code>function loadIt() {
  aGlobal = new Audio();
  aGlobal.addEventListener('x-palm-connect',
      function(evt){
          evt.target.palm.audioClass = &quot;media&quot;;
          evt.target.addEventListener(...);
          evt.target.addEventListener(...);
          evt.target.addEventListener(...);
          evt.target.src=&quot;/foo.mp3&quot;;
      },
      false);
}  
</code>
</pre>
    </blockquote>
    <h3 id="disconnectwatchdog-event">
      Disconnect/Watchdog Event
    </h3>
    <p>
      Applications should listen for <code>X_PALM_DISCONNECT</code> and <code>X_PALM_WATCHDOG</code> events because they signify a fatal error communicating with the media server. If either event is received, an application should stop using the current HTMLMediaElement, remove it from the DOM, and attempt to create a new object.
    </p>
    <h2 id="error-codes-and-additional-information">
      Error Codes and Additional Information
    </h2>
    <p>
      The following errors are generated by Audio, Camera, and Video objects.
    </p>
    <table border="0">
      <tbody>
        <tr>
          <th>
            Definition
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            MediaError.MEDIA_ERR_ABORTED
          </td>
          <td>
            Equals HTML5 aborted error value.
          </td>
        </tr>
        <tr>
          <td>
            MediaError.MEDIA_ERR_CAPTURE
          </td>
          <td>
            Returned from Camera object if capture failed.
          </td>
        </tr>
        <tr>
          <td>
            MediaError.MEDIA_ERR_DECODE
          </td>
          <td>
            Equals HTML5 decode error value.
          </td>
        </tr>
        <tr>
          <td>
            MediaError.MEDIA_ERR_NETWORK
          </td>
          <td>
            Equals HTML5 network error value.
          </td>
        </tr>
        <tr>
          <td>
            MediaError.MEDIA_ERR_SAVE
          </td>
          <td>
            Returned from Camera object if save failed.
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      An application must register for error events (<code>addEventHandler(Media.Event.ERROR, ...)</code>) to get error callbacks. The event passed to the callback (through the first argument) contains the type of the event, which in this case is &quot;error&quot;, and the target for the event.
    </p>
    <h3 id="extended-error-information">
      Extended Error Information
    </h3>
    <p>
      Additional error information, beyond that defined by the HTML5 specification, is also passed to the application through the <code>.palm.errorDetails</code> object.
    </p>
    <p>
      There are three fields in <code>errorDetails</code>: <code>errorClass</code>, <code>errorCode</code>, and <code>errorValue</code>. These fields contain the raw error information from the media server, as defined in the following table. An application <strong>must</strong> first check the standard HTML5 error value to determine whether the extended information is relevant.
    </p>
    <p>
      All errors have the 3 MS Bytes set to 0xE00505.
    </p>
    <table border="0">
      <tbody>
        <tr>
          <th>
            ErrorClass
          </th>
          <th>
            ErrorCodes
          </th>
          <th>
            Notes
          </th>
        </tr>
        <tr>
          <td>
            kMediaDecodeError (0xE0000501)
          </td>
          <td>
            kMediaDecodeErrorFileNotFound (1), kMediaDecodeErrorBadParam(2), kMediaDecodeErrorPipeline (3), kMediaDecodeErrorUnsupported (4), kMediaDecodeErrorNoMemory (5)
          </td>
          <td>
            All errors related to the parameters or the stream.
          </td>
        </tr>
        <tr>
          <td>
            kMediaNetworkError (0xE0000502)
          </td>
          <td>
            kMediaNetworkErrorHttp (6), kMediaNetworkErrorRtsp (7), kMediaNetworkErrorMobi (8), kMediaNetworkErrorOther(9),<br>
            kMediaNetworkErrorPowerDown(12)<br>
          </td>
          <td>
            All errors related to the network or streaming (except 12 which is generic).<br>
          </td>
        </tr>
        <tr>
          <td>
            kMediaCaptureError (0xE0000503)
          </td>
          <td>
            kMediaCaptureErrorCaptureFailed (10), kMediaCaptureErrorImageSaveFailed (11)
          </td>
          <td>
            All capture related errors.
          </td>
        </tr>
      </tbody>
    </table>
    <h2 id="media-audio-class-tagging">
      Media Audio Class Tagging
    </h2>
    <p>
      The audio class of a piece of media defines how the system deals with the audio for the content. For example, the audio route sending the sound (headset, back speaker, front speaker) or how the sound is treated when receiving a notification or ringtone (e.g., mute, pause, reduce volume).
    </p>
    <p>
      Both Audio and Video objects include a <code>.palm.audioClass</code> parameter. You should set this parameter before starting playback of media.
    </p>
    <p>
      Example:
    </p>
    <blockquote>
      <pre>
<code>var obj = new Audio();
obj.palm.audioClass = Media.AudioClass.MEDIA;
obj.src=&quot;/file.mp3&quot;; 
</code>
</pre>
    </blockquote>
    <h3 id="special-considerations-for-audio-tagged-as-media">
      Special Considerations for Audio Tagged as MEDIA
    </h3>
    <p>
      Most audio classes simply control the volume, speaker the mixing. However, streams tagged <code>Media.AudioClass.MEDIA</code> have some extra behavior, as follows:
    </p>
    <ul>
      <li>Only one playing <code>Media.AudioClass.MEDIA</code> stream: If a stream tagged as media opens, any currently playing media stream pauses.
      </li>
      <li>Pause on incoming call: The playing media stream automatically pauses if the phone rings.
      </li>
      <li>Automatically resume on call end: If desired, the application can call <code>.palm.setAutoResumeOnCallEnd(true/false)</code>.
      </li>
    </ul>
    <p>
      Applications using the <code>Media.AudioClass.MEDIA</code> audio class should anticipate their stream being paused unexpectedly. Therefore, it is important that their UI updates appropriately, when playback pauses/resumes. An application should register for the <code>Media.Event.PAUSE</code> and <code>Media.Event.PLAY</code> events to correctly update their UI to reflect the playback state.
    </p>
    <h2 id="additional-streaming-data">
      Additional Streaming Data
    </h2>
    <p>
      The section discusses the properties on the Palm extension to the HTMLMediaElement. They provide additional information about the buffering and playback rate of streaming content.
    </p>
    <h3 id="bitrate">
      Bitrate
    </h3>
    <p>
      The <code>.palm.bitrate</code> object on an HTMLMediaElement has the following properties:
    </p>
    <ul>
      <li>audio.average
      </li>
      <li>audio.estimate
      </li>
      <li>audio.maximum
      </li>
      <li>video.average
      </li>
      <li>video.estimate
      </li>
      <li>video.maximum
      </li>
    </ul>
    <p>
      These properties are set with data from the stream being played. The average and maximum bitrates are set from data in the container for the stream. After receiving the <code>CANPLAY</code> event, the values are considered valid. If there is no bitrate information present in the container (they are optional), both <code>audio.estimate</code> and <code>video.estimate</code> are set to <code>true</code>.
    </p>
    <p>
      Example:
    </p>
    <blockquote>
      <pre>
<code>var a = new Audio();
...
// An audio stream shouldn't have video
if (a.palm.bitrate.audio.estimate == false) {
  Mojo.log(
      &quot;bitrates: &quot;,
      a.palm.bitrate.audio.average,
      &quot;/&quot;,
      a.palm.bitrate.audio.maximum);
} 
</code>
</pre>
    </blockquote>
    <h3 id="buffering-rate">
      Buffering Rate
    </h3>
    <p>
      The HTTP source element provides an average of the download rate from the server; <code>palm.bufferingRate</code> holds the buffering bytes/second value for the current stream.
    </p>
    <h3 id="consumption-rate">
      Consumption Rate
    </h3>
    <p>
      The HTTP source element provides the average data rate being pulled by the downstream component; <code>palm.consumptionRate</code> holds the average pull rate.
    </p>
    <h2 id="setting-properties-on-the-gstreamer-pipeline">
      Setting Properties on the GStreamer Pipeline
    </h2>
    <p>
      This is a low-level API that allows properties to be set on an open mediaserver stream.
    </p>
    <p>
      To passdown properties to mediaserver components, use <code>palm.setStreamProperty(property, value)</code>. Currently the following are exposed:
    </p>
    <ul>
      <li>rtsp_describe_proxy_auth
      </li>
      <li>rtsp_header_additions
      </li>
      <li>rtsp_proxy_ip
      </li>
      <li>rtsp_proxy_port
      </li>
    </ul>
    <h2 id="releasing-the-video-sink">
      Releasing the Video Sink
    </h2>
    <p>
      When an application sets the &quot;video sink&quot;, it controls the location of the video for the playing content. When an application is not in the foreground, it loses control of the video sink, so another foreground application can use it to display video.
    </p>
    <p>
      Applications can release the video sink themselves, but are not required to do so.
    </p>
    <table border="0">
      <tbody>
        <tr>
          <th>
            Command
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            obj.palm.freeVideoSink()
          </td>
          <td>
            Releases the video sink. The application can continue to play video, but the UI does not updated.
          </td>
        </tr>
        <tr>
          <td>
            obj.palm.renderMode
          </td>
          <td>
            Controls the destination where the video sink outputs the video. There are three valid settings:<br>
            <ul>
              <li>video.palm.renderMode = 'overlay' - Renders normally to the video sink.
              </li>
              <li>video.palm.renderMode = 'rgb' - Grabs a frame of video, but continues to hold the video sink open.
              </li>
              <li>video.palm.renderMode = 'null' - Releases the video sink. The application can continue to play video, but the UI does not updated.
              </li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      An application does not need to do anything to release the video sink, this happens automatically when the application loses focus (gets carded). However, the application developer may want to pause the video playback when carded because video is not visible.
    </p>
    <h2 id="video-scaling-in-full-screen-mode">
      Video Scaling in Full Screen Mode
    </h2>
    <p>
      <strong>Note:</strong>
    </p>
    <p>
      Video Scaling is only implemented for fullscreen video.
    </p>
    <p>
      Video fits into the display rectangle according to the value set in <code>fitMode</code>. If <code>fitMode</code> is set to <code>&quot;fit&quot;</code>, the video only stretches until the larger dimension fills the window. There may be black bars in the other dimension.
    </p>
    <p>
      If <code>fitMode</code> is set to <code>&quot;fill&quot;</code>, the video size scales until the entire screen contains the video, though this may result in some cropping on one dimension.
    </p>
    <blockquote>
      <pre>
<code>var video = new Video(&quot;file.mp4&quot;);
...
function someButtonHandler(toggleState){
  // Assuming toggleState is a boolean attached to the state
  // of an onscreen button...
  if (toggleState){
      // When true we want to fill the screen
      video.palm.fitMode = 'fill';
  }  else {
      video.palm.fitMode = 'fit';
  }
} 
</code>
</pre>
    </blockquote>
    <h2 id="using-a-non-fullscreen-view-rectangle">
      Using a Non-Fullscreen View Rectangle
    </h2>
    <p>
      To use a non-fullscreen view rectagle, use the following code:
    </p>
    <blockquote>
      <pre>
<code>video.palm.windowed = true;
video.palm.setViewRectangle(left, top, width, height);
</code>
</pre>
    </blockquote>
    <h2 id="setting-the-video-orientation">
      Setting the Video Orientation
    </h2>
    <p>
      The orientation of the video is controlled independently of the window or devices orientation. By default, video plays with the assumption that the device rotates left (counter-clockwise) degrees. Set the <code>video.palm.windowOrientation</code> to ensure the correct orientation for the carded video. For example, <code>video.palm.windowOrientation = 'left'</code>. Valid values are &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, and &quot;right&quot;.
    </p>
    <h2 id="adding-a-media-object-to-the-dom">
      Adding a Media Object to the DOM
    </h2>
    <p>
      Using the standard HTML5 constructor (for example, <code>var a = new Audio();</code>), you create a media object and append it to the DOM of the current document. That API does not give you much control over <em>where</em> in the DOM the document is added and <em>may</em> cause problems with applications containing multiple scenes.
    </p>
    <p>
      The preferred way to create a media object is to extend an existing HTML <code>div</code> object by using <code>AudioTag.extendElement()</code>, as shown in the following code:
    </p>
    <blockquote>
      <pre>
<code>&lt;html&gt;
  &lt;head&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
  function myExampleFunction(){
      // Do some setup
      var audioElem = AudioTag.extendElement($('someDiv'));
      // Do standard HTML5 media actions with the object
      audioElem.src=&quot;http://domain.dom/path/to/audio.mp3&quot;;
      ...
  }

  // This function is called in response to some event that requires playback audio
  function myFooHandler(){
      // Get reference to the audio object by referring to HTML DIV
      var audio = $('someDiv');
      audio.play();
  }
  &lt;/script&gt;
  &lt;/head&gt;
  
  &lt;body&gt;
  &lt;div id=&quot;someDiv&quot; controls=&quot;false&quot; autoplay=&quot;false&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt; 
</code>
</pre>
    </blockquote>
    <p>
      When you do this, you add the media functionality to an existing <code>&lt;div&gt;</code> in the page/scene. This means that after popping the scene and removing the scene DOM, the audio object is also cleaned up.
    </p>
    <p>
      <strong>Note:</strong>
    </p>
    <p>
      The audio stops playing after removing the div from the DOM.
    </p>
    <h2 id="constructors-for-audio-and-video-objects">
      Constructors for Audio and Video objects
    </h2>
    <p>
      The expected way to create an Audio or Video object is to use the corresponding <code>AudioTag.extendElement()</code> and <code>VideoTag.extendElement()</code> methods. However, a default constructor for an audio object does exist (<code>new Audio()</code>). Calling <code>new Video()</code> generates an exception because the Video object requires that a <code>&lt;div&gt;</code> tag be specified representing the size and position of the video on the screen.
    </p>
    <p>
      The constructor that supports passing the div (as a name or element) exists for both Audio and Video classes, but is deprecated. <code>new Video(url, div)</code> and <code>new Audio(url, div)</code> are currently both defined.
    </p>
		</div>
	</body>
</html>