/*
  WARNING: DO NOT EDIT THIS FILE

  The webview widget now lives in its own component. This file is being left here until the tools other than bitbake can
  be updated to install it from its new location.
*/

/**
 * @name widget_webview.js
 * @fileOverview TBD documentation;
 * See {@link Mojo.Widget.WebView} for more info.
 */
if (Mojo.WebView === undefined) {
	Mojo.WebView = {
		MouseModeSelect: 0,
		MouseModeScroll: 1
	};
}

Mojo.WebView.Rectangle = Class.create({

	initialize: function(left, top, right, bottom) {
		this.left = left;
		this.top = top;
		this.right = right;
		this.bottom = bottom;
	},
	
	equals: function(rect) {
		return this.left === rect.left && this.top === rect.top &&
					this.right === rect.right && this.bottom === rect.bottom;
	},
	
	offset: function(dx, dy) {
		this.left  += dx;
		this.right += dx;
		this.top   += dy;
		this.bottom+= dy;
	},

	toString: function() {
		return "L: " + this.left + ", T: " + this.top + ", R: " + this.right + ", B: " + this.bottom;
	}
});

/*
 * An entry in the browser forward/back (i.e. session) history.
 * @param {String} url The page's URL.
 * @param {Number} scrollX	The page X scroll position.
 * @param {Number} scrollY	The page Y scroll position.
 * @param {Number} zoom	 The page zoom level.
 */
Mojo.WebView.HistoryItem = Class.create({
	
	initialize: function(url, scrollX, scrollY, width, height, zoom) {
		this.url = url;
		this.scrollX = scrollX || 0;
		this.scrollY = scrollY || 0;
		this.width = width || 320;
		this.height = height || 480;
		this.zoom = zoom || 1.0;
	}
});

Mojo.WebView.MetaViewport = Class.create({

	initialize: function(initialScale, minimumScale, maximumScale, width, height, userScalable) {
		this.initialScale = initialScale;
		this.minimumScale = minimumScale;
		this.maximumScale = maximumScale;
		this.width = width;
		this.height = height;
		this.userScalable = userScalable;
	}
});

/*
 * @private
 * @constant 
 * @description The first paint (rendering) of the web page has finished. More may
 *              follow as the page continues to load.
 *
 * Supported Widgets
 *
 * - {@link Mojo.Widget.WebView}
 */
Mojo.Event.webViewFirstPaintComplete = 'mojo-webview-first-paint-complete';

/**
#### Overview ####
To embed a contained web object, you would declare and instantiate a webView widget. You can bound the 
widget within your declaration to get a scrolling view, or allow it to take over an entire scene at 
your discretion. You can use it render local markup or to load an external URL; as long as you can 
define the source as a URL it can be applied.


#### Declaration ####

		<div x-mojo-element="WebView" id="WebId" class="WebClass" name="WebName"></div>

		Properties		Required	Value			Description 
		---------------------------------------------------------------------------------------------------------------------------------
	    x-mojo-element	Required	WebView			Declares the widget as type 'WebView' 
	    id				Required	Any String		Identifies the widget element for use when instantiating or rendering
	    class			Optional	Any String		Provide your own unique class and override the frameworks styles
	    name			Optional	Any String		Add a unique name to the WebView widget; generally used in templates when used 


#### Events ####

		Mojo.Event.listen("WebId",'mojo-webViewLoadProgress', this.handleUpdate)

		Event Type						Value							Event Handling
		---------------------------------------------------------------------------------------------------------------------------------
		Mojo.Event.webViewLoadStarted									indicates the WebView widget has started loading the content
		Mojo.Event.webViewLoadProgress	progress						indicates that some progress has been made in loading content and returns the amount in 
																		progress. Note: this will show 100% even in the case of a failed page load.
		Mojo.Event.webViewLoadStopped 									indicates the page has finished loading; note: "finished loading" is a tricky concept in 
																		AJAX web pages, so be careful how you use this event
		Mojo.Event.webViewLoadFailed	errorCode, message 				indicates the content failed to load and supplies an error code (errorCode) and 
																		localized message (message)
		Mojo.Event.webViewDownloadFinished url, mimeType, tmpFilePath	File download completed
		Mojo.Event.webViewLinkClicked	url								The user tapped a link
		Mojo.Event.webViewTitleUrlChanged title, url, canGoBack, canGoForward
		Mojo.Event.webViewTitleChanged	title
		Mojo.Event.webViewUrlChanged	url, canGoBack, canGoForward
		Mojo.Event.webViewCreatePage	pageIdentifier
		Mojo.Event.webViewTapRejected
		Mojo.Event.webViewScrollAndScaleChanged
		Mojo.Event.webViewEditorFocused	focused
		Mojo.Event.webViewUpdateHistory	url, reload
		Mojo.Event.webViewSetMainDocumentError domain, errorCode, failingURL, message
		Mojo.Event.webViewServerConnect
		Mojo.Event.webViewServerDisconnect
		Mojo.Event.webViewResourceHandoff
		Mojo.Event.webViewFirstPaintComplete
		Mojo.Event.webViewUrlRedirect	url, appId
		Mojo.Event.webViewModifierTap	up, linkInfo
		Mojo.Event.webViewMimeNotSupported	url, mimeType				indicates the BrowserServer cannot handle a given URL
		Mojo.Event.webViewMimeHandoff	url, mimeType					indicates the BrowserServer cannot (or isn't supposed to) handle a mime type.
		Mojo.Event.webViewPluginSpotlightStart  
		Mojo.Event.webViewPluginSpotlightEnd

    
#### Instantiation ####
  
		this.controller.setupWidget("WebId",
			this.attributes = {
				url:	'http://www.palm.com',
				minFontSize:18,
				virtualpagewidth: 20,
				virtualpageheight: 10
				},
			this.model = {
				}
		});


#### Attribute Properties ####

		Attribute Property	Type		Required	Default		Description
		---------------------------------------------------------------------------------------------------------------------------------
	    virtualpageheight   Integer     Optional    ?           The browser's virtual page height.
	    virtualpagewidth    Integer     Optional    ?           The browser's virtual page width.
	    urL                 String      Required    None        The initial URL to display.
	    pageIdentifier      String      Optional    ?           The BrowserServer page identifier. This is used when the BrowserServer
																instructs an application to open a new page.
	    minFontSize         Integer     Optional    ?           The minimum font size that the browser will display.
	    topMargin           Integer     Optional    ?           The margin above the web view that is scrolled off the screen when a new page is loaded.
	    cacheAdapter        Boolean     Optional    undefined   If true, cache this adapter, false if not, or undefined to not specify and use the
																browser-adapter default. Default is undefined.
	    interrogateClicks   Boolean     Optional    true        If the host application wants to be called for every hyperlink click via
																Mojo.Event.webViewLinkClicked event
	    showClickedLink		Boolean     Optional    true        Styles clicked link with grey background and border.														


#### Model Properties ####

		Model Property		Type			Required	Default		Description     
		---------------------------------------------------------------------------------------------------------------------------------
		None 

 
#### Methods ####

		Method				Arguments									Description
		---------------------------------------------------------------------------------------------------------------------------------
		setTopMargin		Integer										Set the top margin (in pixels)
		clearCache			None										Clear browser cache. Will clear the cache for all open pages.
		clearCookies		None										Clear browser cookies. Will clear cookies for all open pages.
		deleteImage			String {fname}								Delete the image file specified by the argument.
		generateIconFromFile String {inFilName}, String {outFileName},	Generate a 64x64 pixel icon from a portion of an input file.
							Number {left}, Number {top},				The output icon will be given a drop shadow and sheen
							Number {right}, Number {bottom}				consistent with other launcher icons.
		goBack				None										Go to the previous page in the user's browing history.
		goForward			None										Go to the next page in the user's browsing history.
		openURL				String										Navigate to the specified url in the webview
		reloadPage			None										Reload the currently loaded page
		resizeImage 		String {inFileName}, String {outFileName},	Resize the input file (PNG format only) to the specified width/height and
							Number {width}, Number {height}				write the new image to the specified output file. Note that pathnames must
																		be relative names (for example '/tmp/image.png', rather than a URL like
																		file://var/usr/applications/myApp/images/image.png).
		getHistoryState		Function {successCb}						Retrieve the current history state from the Browser server.
																		Will call successCb with results.
		isEditing           Function {callback}                         Determines if an editable field is in focus
		                                                                Will call "callback" with boolean value
		insertStringAtCursor String {string}                            Inserts given string at cursor position of editable field in focus
		setBlockPopups		Boolean										Enable or disable popup blocking. This setting is on a
																		per-WebView widget basis.
		setAcceptCookies	Boolean										Enable or disable accepting cookies. This setting is on a
																		per-WebView widget basis.
		addUrlRedirect		String {urlRe}, Boolean {redirect},			Add a URL redirect. When the browser server nagivates to a URL
							Object {userData}, Number {type}			matching urlRe and redirect is true then it will not navigate
																		to that URL and instead send a Mojo.Event.webViewUrlRedirect event.
		addSystemRedirects	String {appId}								Add all entries from the system's command/resource handlers table
																		The optional appId parameter can be used to omit all
																		command/resource handler entries that match a given app ID.
		saveViewToFile		String {fname}, Number {left}, Number {top}	Save the current view to the specified file. The save region
							Number {width}, Number {height}				is optional. If omitted then the full view will be saved to fname.
		setEnableJavaScript Boolean										Enable or disable javascript This setting is on a 
																		per-WebView widget basis.
		stopLoad			None										Stop loading the current page
		focus				None										Focus the webview widget			
		blur				None										Blur the webview widget
		clearHistory		None										Clear session history. This setting is on a
																		per-WebView widget basis.
		setShowClickedLink	Boolean										Enhance the showing of a clicked link. This setting is on a
																		per-WebView widget basis.
	    copy                Function {callback} 
		selectAll           None
		pluginSpotlightRemove	None	Webview gets out of the spotlight mode, 
																in which gestures only go into the spotlight rect. 
																Gestures modified by meta go into the adapter 
																and not into the spotlight.

		pluginSpotlightCreate	Number {left}, Number {top}, Number {right}, Number {bottom}, String {mode},  Boolean {notifyClient})	Create spotlight at given rectangle

@field
*/
Mojo.Widget.WebView = Class.create({

	smartZoomScaleSlopFactor: 1.05,
	mouseDownEventType: 0,
	mouseUpEventType: 1,
	mouseMoveEventType: 2,
	maxScaleFactor: 2.0,
	minScaleFactor: 0.1,
	adapterNum: 0,
	formAutoZoomScaleFactor: 1.4,

	initialize: function() {
		this.useAdapter = Mojo.Host.current === Mojo.Host.palmSysMgr;
		this.adapter = 0;
		this.sceneScroller = null;
		this.tapIndex = 0;
		this.currScale = 1.0;
		this.currPageWidth = 0;
		this.currPageHeight = 0;
		this.fitWidth = true;
		this.metaViewport = undefined;
		this.adapterConnected = true;
		this.zoomAtGestureStart = this.currScale;
		this.offsetAtGestureStart = {left: 0, top: 0};
		this.javascriptDialog = null;
		this.useMouseEvents = false;
		this.mouseScrollsNode = false;
		this.userCanAlwaysScale = true;
		this.formAutoZoom = true;
		this.historyInfo = {};
		this._lastTapEvent = undefined;
		this._deleteLastTapEvent = this._deleteLastTapEvent.bind(this);
		this.lastUrl = null;
		this.pageManipulated = false; ///< Was the current page scrolled or zoomed?
		this.pageGotSize = false; /// Got size of the page
		this._lastTapElementInfo = {};
		this._lastMousemoveEvent = undefined;  // used to stop repeating identical mousemoves
		

		this.prevWindowSize = {width: 0, height: 0};
		this.prevScrollPosition = {x: 0, y: 0};

		this.inPinchZoom = false;
		this.pinchZoomRecordedScales = [];
		this.pinchZoomRecordedCenterX = [];
		this.pinchZoomRecordedCenterY = [];
		this.pinchZoomAvgWeights = [ 1, 2, 4, 8 ];

		this.pluginSpotlightMode = undefined;
		this.pluginSpotlightOn = false;
		this.pluginSpotlightRemoveTimer = undefined;
		this.pluginSpotlightRect = undefined;
		this.pluginSpotlightScrim = {fullscreen : 255, partial : 130};
		this.pluginSpotlightAllowMetaGestures = false;
		this.pluginSpotlightViewportAtStart = { canRestore : false, scale : this.currScale, scrollPos : {left : 0, top : 0}, height : 0, width : 0};

		this.hasFocus = true;
		this.topMargin = 0;
		this._doubleClickHandler = this._handleDoubleClick.bind(this);
		this._singleTapHandler = this._handleSingleTap.bindAsEventListener(this);
		this._tapHandler = this._handleTap.bind(this);
		this._dragStartHandler = this._handleDragStart.bindAsEventListener(this);
		this._gestureStartHandler = this._handleGestureStart.bind(this);
		this._gestureChangeHandler = this._handleGestureChange.bind(this);
		this._gestureEndHandler = this._handleGestureEnd.bind(this);
		this._windowResizeHandler = this._handleWindowResize.bindAsEventListener(this);
		this._addAsScrollListener = this._addAsScrollListener.bind(this);
		this._cardActivate = this._cardActivate.bindAsEventListener(this);
		this._cardDeactivate = this._cardDeactivate.bindAsEventListener(this);
		this._activateHandler = this._activate.bind(this);
		this._deactivateHandler = this._deactivate.bind(this);
		this._connectAdapterToServer = this._connectAdapterToServer.bind(this);
		this._mouseDownHandler = this._handleMouseDown.bindAsEventListener(this);
		this._mouseUpHandler = this._handleMouseUp.bindAsEventListener(this);
		this._mouseMoveHandler = this._handleMouseMove.bindAsEventListener(this);
		
		// Event handlers for interactive element highlighting
		this._mouseDownHandlerHighlight = this._handleMouseDownHighlight.bindAsEventListener(this);
		this._mouseUpHandlerHighlight = this._handleMouseUpHighlight.bindAsEventListener(this);
		this._mouseMoveHandlerHighlight = this._handleMouseMoveHighlight.bindAsEventListener(this);
		this._keyDownHandlerHighlight = this._handleKeyDownHighlight.bindAsEventListener(this);
		this.isElementHighlighted = false;
		this._addElementHighlight = this._addElementHighlight.bind(this);
		this._removeElementHighlight = this._removeElementHighlight.bind(this);
		
		// Event handlers for plugin spotlight
		this._holdHandlerPluginSpotlight = this._handleHoldPluginSpotlight.bindAsEventListener(this);
		this._mouseUpHandlerPluginSpotlight = this._handleMouseUpPluginSpotlight.bindAsEventListener(this);
		this._keyDownHandlerPluginSpotlight = this._handleKeyDownPluginSpotlight.bindAsEventListener(this);
		this._keyUpHandlerPluginSpotlight = this._handleKeyUpPluginSpotlight.bindAsEventListener(this);

		this.popupCallbacks = [];

		this._keyDownHandlerTrackball = this._handleKeyDownTrackball.bindAsEventListener(this);
		this._keyUpHandlerTrackball = this._handleKeyUpTrackball.bindAsEventListener(this);

		this.selectionMode = false;
		this.selectionDisabledTime = 0;
		this.trackballMode = false;

		this.addElementHighlightTimer = undefined;
		this.removeElementHighlightTimer = undefined;
	},

	/**
	 * A helper function to sanitize incoming strings from the
	 * browserserver (removes tags and scripts)
	 */
	$X: function(val) {
		return val.stripScripts().stripTags();
	},

    setup: function() {
		
		this.controller.scene.pushCommander(this);  // for handling menu commands
		
		try {
			if (this.controller.attributes.minimumpageheight === undefined) {
				this.controller.attributes.minimumpageheight = this.controller.window.innerHeight;
			}

			if (this.useAdapter) {
				// Create the browser adapter
				this.adapter = this.controller.document.createElement("object");
				
				this.adapter.setAttribute('x-palm-pass-event', true);
				this.adapter.setAttribute(Mojo.Gesture.consumesEnterAttribute, true);
				this.adapter.setAttribute("type", "application/x-palm-browser");
				if (this.controller.attributes.cacheAdapter !== undefined) {
					this.adapter.setAttribute("x-palm-cache-plugin", this.controller.attributes.cacheAdapter ? 'true' : 'false');
				}
				if (this.controller.attributes.virtualpagewidth) {
					this.adapter.setAttribute("virtualPageWidth", this.controller.attributes.virtualpagewidth);
				}
				if (this.controller.attributes.virtualpageheight) {
					this.adapter.setAttribute("virtualPageHeight", this.controller.attributes.virtualpageheight);
				} else {
					this.controller.attributes.virtualpageheight = this.controller.window.innerHeight;
				}
				if (this.controller.attributes.useMouseEvents) {
					this.adapter.setAttribute("useMouseEvents", this.controller.attributes.useMouseEvents);
					this.useMouseEvents = true;
				}
				if (this.controller.attributes.fitWidth === undefined) {
					this.controller.attributes.fitWidth = true;
				}
				this.fitWidth = this.controller.attributes.fitWidth;
				if (this.controller.attributes.userCanAlwaysScale !== undefined) {
					this.userCanAlwaysScale = this.controller.attributes.userCanAlwaysScale;
				}
				if (this.controller.attributes.formAutoZoom !== undefined) {
					this.formAutoZoom = this.controller.attributes.formAutoZoom;
				}
				
				this.adapter.eventListener = this;
			}
			else {
				// Create a test image we can use in place of the adapter.
				this.adapter = this.controller.document.createElement("img");
				this.adapter.setAttribute("src", "icon.png");
				this.adapter.setStyle("width: 100%; height: 100%; -webkit-user-drag: none;");
			}

			this.adapter.id = "browser-adapter-" + this.adapterNum;
			this.adapterNum += 1;
			
			if (this.controller.attributes.topMargin) {
				this.topMargin = this.controller.attributes.topMargin;
			}
			
			this.prevWindowSize.width = this.controller.window.innerWidth;
			this.prevWindowSize.height = this.controller.window.innerHeight;
			
			// Initialize the width, height to that of the window. This is used for
			// setting the initial dimensions of the adapter view.
			// FIXME: This is used only  should be configurable by the caller
			this.adapter.setAttribute("width", this.controller.window.innerWidth);
			this.adapter.setAttribute("height", this.controller.attributes.virtualpageheight);
			
			this._setDimensions(this.adapter, 
								this.controller.window.innerWidth, 
								this.controller.window.innerHeight);

            this.topScroller = Mojo.View.getScrollerForElement(this.controller.element);
			this.sceneScroller = this.topScroller._mojoController.assistant;

			this.controller.element.insert(this.adapter);

			this.controller.document.addEventListener(Mojo.Event.stageActivate, this._cardActivate, false);
			this.controller.document.addEventListener(Mojo.Event.stageDeactivate, this._cardDeactivate, false);
			this.controller.scene.listen(this.controller.scene.sceneElement, Mojo.Event.activate, this._activateHandler);
			this.controller.scene.listen(this.controller.scene.sceneElement, Mojo.Event.deactivate, this._deactivateHandler);

			Mojo.Event.listen(this.adapter, 'mousedown', this._mouseDownHandler);
			Mojo.Event.listen(this.adapter, 'mouseup', this._mouseUpHandler);
			Mojo.Event.listen(this.adapter, 'mousemove', this._mouseMoveHandler);

			if (!this.useMouseEvents) {

				Mojo.Event.listen(this.adapter, 'dblclick', this._doubleClickHandler);			
				Mojo.Event.listen(this.adapter, Mojo.Event.tap, this._tapHandler, false);
				Mojo.Event.listen(this.adapter, 'singletap', this._singleTapHandler, false);
			}

			this.controller.exposeMethods(['setTopMargin', 
			"clearCache", "clearCookies", "deleteImage", "generateIconFromFile", "smartZoomAtPt", "elementInfoAtPoint",
			"goBack",  "goForward",	"openURL",  "reloadPage", "resizeImage", "saveImageAtPoint", "getImageInfoAtPoint",
			"getHistoryState", "isEditing", "insertStringAtCursor", "setBlockPopups", "setAcceptCookies",
			"addUrlRedirect", "addSystemRedirects", "saveViewToFile", "setEnableJavaScript", "stopLoad", "inspectUrlAtPoint",
			"registerOnPopup", "unregisterOnPopup", "focus", "blur", "clearHistory", "setShowClickedLink",
			"interactiveAtPoint", "copy", "selectAll", "paste", "_setScrollNode", "pluginSpotlightCreate", "pluginSpotlightRemove"]);

			Mojo.Log.info("WebView widget is setup");
		}
		catch (e) {
			Mojo.Log.logException(e, 'setup');
		}
	},

	cleanup: function() {

		this.controller.document.removeEventListener(Mojo.Event.activate, this._cardActivate, false);
		this.controller.document.removeEventListener(Mojo.Event.deactivate, this._cardDeactivate, false);
		this.controller.scene.stopListening(this.controller.scene.sceneElement, Mojo.Event.activate, this._activateHandler);
		this.controller.scene.stopListening(this.controller.scene.sceneElement, Mojo.Event.deactivate, this._deactivateHandler);

		this.controller.scene.removeCommander(this);

		Mojo.Event.stopListening(this.adapter, 'mousedown', this._mouseDownHandler);
		Mojo.Event.stopListening(this.adapter, 'mouseup', this._mouseUpHandler);
		Mojo.Event.stopListening(this.adapter, 'mousemove', this._mouseMoveHandler);

		if (!this.useMouseEvents) {
			Mojo.Event.stopListening(this.adapter, 'dblclick', this._doubleClickHandler);			
			Mojo.Event.stopListening(this.adapter, Mojo.Event.tap, this._tapHandler, false);
			Mojo.Event.stopListening(this.adapter, 'singletap', this._singleTapHandler, false);
		}

		this.adapter = null;
	},

	_activate: function() {

		Mojo.Log.info("WebView#_activate()");
		Mojo.Event.listen(this.controller.document, 'gesturestart', this._gestureStartHandler, false);
		Mojo.Event.listen(this.controller.document, 'gesturechange', this._gestureChangeHandler, false);
		Mojo.Event.listen(this.controller.document, 'gestureend', this._gestureEndHandler, false);
		Mojo.Event.listen(this.controller.element, Mojo.Event.dragStart, this._dragStartHandler, false);
		Mojo.Event.listen(this.topScroller, Mojo.Event.scrollStarting, this._addAsScrollListener, false);
		Mojo.Event.listen(this.controller.window, 'resize', this._windowResizeHandler, false);

		if (!this.useMouseEvents) {
			Mojo.Event.listen(this.adapter, 'mousedown', this._mouseDownHandlerHighlight);
			Mojo.Event.listen(this.adapter, 'mouseup', this._mouseUpHandlerHighlight);
			Mojo.Event.listen(this.adapter, 'mousemove', this._mouseMoveHandlerHighlight);
			Mojo.Event.listen(this.adapter, 'keydown', this._keyDownHandlerHighlight);

			Mojo.Event.listen(this.adapter, 'keydown', this._keyDownHandlerTrackball);
			Mojo.Event.listen(this.adapter, 'keyup', this._keyUpHandlerTrackball);
			
			Mojo.Event.listen(this.adapter, Mojo.Event.hold, this._holdHandlerPluginSpotlight);		
			Mojo.Event.listen(this.adapter, 'mouseup', this._mouseUpHandlerPluginSpotlight);
			Mojo.Event.listen(this.adapter, 'keydown', this._keyDownHandlerPluginSpotlight);
			Mojo.Event.listen(this.adapter, 'keyup', this._keyUpHandlerPluginSpotlight);

		}

		// The scene scroller reverts to vertical when it is re-shown so we set it each time
		// the scene is activated.
		this.topScroller.mojo.setMode("dominant");

		if (this.useAdapter) {
			this.adapter.pageFocused(this.hasFocus);
		}
	},

	_deactivate: function() {

		Mojo.Log.info("WebView#_deactivate()");

		if (!this.useMouseEvents) {
			Mojo.Event.stopListening(this.adapter, 'mousedown', this._mouseDownHandlerHighlight);
			Mojo.Event.stopListening(this.adapter, 'mouseup', this._mouseUpHandlerHighlight);
			Mojo.Event.stopListening(this.adapter, 'mousemove', this._mouseMoveHandlerHighlight);
			Mojo.Event.stopListening(this.adapter, 'keydown', this._keyDownHandlerHighlight);

			Mojo.Event.stopListening(this.adapter, 'keydown', this._keyDownHandlerTrackball);
			Mojo.Event.stopListening(this.adapter, 'keyup', this._keyUpHandlerTrackball);
			
			Mojo.Event.stopListening(this.adapter, Mojo.Event.hold, this._holdHandlerPluginSpotlight);
			Mojo.Event.stopListening(this.adapter, 'mouseup', this._mouseUpHandlerPluginSpotlight);
			Mojo.Event.stopListening(this.adapter, 'keydown', this._keyDownHandlerPluginSpotlight);
			Mojo.Event.stopListening(this.adapter, 'keyup', this._keyUpHandlerPluginSpotlight);
		}

		this._removeElementHighlight();
		this._disableSelectionMode();

		Mojo.Event.stopListening(this.controller.document, 'gesturestart', this._gestureStartHandler, false);
		Mojo.Event.stopListening(this.controller.document, 'gesturechange', this._gestureChangeHandler, false);
		Mojo.Event.stopListening(this.controller.document, 'gestureend', this._gestureEndHandler, false);
		Mojo.Event.stopListening(this.controller.element, Mojo.Event.dragStart, this._dragStartHandler, false);
		Mojo.Event.stopListening(this.topScroller, Mojo.Event.scrollStarting, this._addAsScrollListener, false);
		Mojo.Event.stopListening(this.controller.window, 'resize', this._windowResizeHandler, false);
	},
	
	clearCache: function() {
		if (this.useAdapter) {
			this.adapter.clearCache();
		}
	},

	clearCookies: function() {
		if (this.useAdapter) {
			this.adapter.clearCookies();
		}
	},

	deleteImage: function(image) {
		if (this.useAdapter) {
			this.adapter.deleteImage(image);
		}
	},

	_setScrollNode: function(enabled) {
		this.mouseScrollsNode = enabled;
	},

	generateIconFromFile: function(src, dst, left, top, right, bottom) {
		if (this.useAdapter) {
			this.adapter.generateIconFromFile(src, dst, left, top, right, bottom);
		}
	},

	getHistoryState: function(onSuccess) {
		if (this.useAdapter) {
			this.adapter.getHistoryState(onSuccess);
		}
		else {
			// Simulate always being able to go forward/back
			onSuccess(true, true);
		}
	},

	inspectUrlAtPoint: function(x, y, callback) {
		if (this.useAdapter) {
			this.adapter.inspectUrlAtPoint(x, y, callback);
		}
		else {
			// Simulate the response
			callback({adapterless:true});
		}
	},

	saveImageAtPoint: function(x, y, outDir, callback) {
		if (this.useAdapter) {
			this.adapter.saveImageAtPoint(x, y, outDir, callback);
		}
		else {
			// Simulate the response
			callback({});
		}
	},

	getImageInfoAtPoint: function(x, y, callback) {
		if (this.useAdapter) {
			this.adapter.getImageInfoAtPoint(x, y, callback);
		}
		else {
			// Simulate the response
			callback({});
		}
	},

	/**
	 * Return the corresponding HTML element information for the given
	 * point (in scaled doc coordinates).
	 */
	elementInfoAtPoint: function(x, y, callback) {
		if (this.useAdapter) {
			this.adapter.elementInfoAtPoint(x, y, callback);
		}
		else {
			// Simulate the response
			callback({});
		}
	},

	/**
	 * Is the point (in scaled doc coordinates) interactive?
	 */
	interactiveAtPoint: function(x, y, callback) {
		if (this.useAdapter) {
			this.adapter.interactiveAtPoint(x, y, callback);
		}
		else {
			// Simulate the response
			callback({});
		}
	},

	/**
	 * Smart zoom at a point given in WebView widget (scaled doc) coordinates.
	 */
	smartZoomAtPt: function(x, y) {


		if (this.useAdapter) {
			this._removeElementHighlight();
			this.adapter.smartZoom(x, y);
		}
		else {
			this.smartZoomCalculateResponseSimple(10, 10, 1000, 2000, 100, 100);
		}
	},

	isEditing: function(callback) {
		if (this.useAdapter) {
			this.adapter.isEditing(callback);
		}
		else {
			callback(false);
		}
	},

	insertStringAtCursor: function(str) {
		if (this.useAdapter) {
			try {
				this.adapter.insertStringAtCursor(str);
			} catch (e) {
				Mojo.Log.warn("Exception inserting string at cursor. %s", e);
			}
		}
	},

	goBack: function() {
		this._saveCurrentPagePosition();
		if (this.useAdapter) {
			this.adapter.goBack();
		}
	},

	goForward: function() {
		this._saveCurrentPagePosition();
		if (this.useAdapter) {
			this.adapter.goForward();
		}
	},

	clearHistory: function() {
		if (this.useAdapter) {
			this.adapter.clearHistory();
		}
		this.historyInfo = {};
	},

	openURL: function(url) {
		this.loadingUrl = url;
		if (this.useAdapter) {
			this.adapter.openURL(url);
		}
		else {
			this.loadStarted();
			this.pageDimensions(0, 0);
			this.titleURLChange("Adapterless", url, false, false);
			this.pageDimensions(500, 1000);
			this.loadStopped();
		}
	},

	reloadPage: function() {
		if (this.useAdapter) {
			this.adapter.reloadPage();
		}
	},

	resizeImage: function(src, dst, width, height) {
		this.adapter.resizeImage(src, dst, width, height);
	},

	addUrlRedirect: function(url, redirect, userData, type) {
		if (this.useAdapter) {
			this.adapter.addUrlRedirect(url, redirect, userData, type);
		}
	},

	/**
	 * Save the current view to the specified file.
	 * 
	 * @param {String} fname  The output file name. (required)
	 * @param {Number} left   Left view relative coordinate. (optional)
	 * @param {Number} top    Top view relative coordinate. (optional)
	 * @param {Number} width  Width of view to save. (optional)
	 * @param {Number} height Height of view to save. (optional)
	 */
	saveViewToFile: function(fname, left, top, width, height) {
		if (this.useAdapter) {
			if (left === undefined && top === undefined && width === undefined && height === undefined) {
				this.adapter.saveViewToFile(fname);
			}
			else {
				this.adapter.saveViewToFile(fname, left, top, width, height);
			}
		}
	},

	setEnableJavaScript: function(value) {
		if (this.useAdapter) {
			this.adapter.setEnableJavaScript(value);
		}
	},

	setBlockPopups: function(value) {
		if (this.useAdapter) {
			this.adapter.setBlockPopups(value);
		}
	},

	setAcceptCookies: function(value) {
		if (this.useAdapter) {
			this.adapter.setAcceptCookies(value);
		}
	},

	stopLoad: function() {
		if (this.useAdapter) {
			this.adapter.stopLoad();
		}
	},

	_cardActivate: function(event) {
		this.hasFocus = true;

		if (this.useAdapter) {
			try {
				this.adapter.pageFocused(this.hasFocus);
			}
			catch (e) {} // Can fail if page scene is not active.
		}

		if (!this.adapterConnected) {
			// This browser page was purged when the application was not in the foreground.
			// Now that we're active again let's reconnect and reload the page.
			Mojo.Log.info("Reconnecting adapter to server.");
			this._connectAdapterToServer();
		} 
	},

	_cardDeactivate: function(event) {
		this.hasFocus = false;

		if (this.useAdapter) {
			try {
				this.adapter.pageFocused(this.hasFocus);
			}
			catch (e) {} // Can fail if page scene is not active.
		}

		// Going in the background stop trying to reconnect to the browser server.
		if (this._serverConnectTimer) {
			this.controller.window.clearTimeout(this._serverConnectTimer);
			delete this._serverConnectTimer;
		}
	},

	/**
	 * Map coordinates from the page coordinates system to the scene coordinate system.
	 * 
	 * @param {Object} pagePos Page position (origin TL).
	 */
	_pageToScene: function(pagePos) {
		return {left: -pagePos.left * this.currScale, top: -pagePos.top * this.currScale};
	},
	
	_sceneToPage: function(scenePos) {
		if (this.currScale !== 0.0) {
			return { left: -scenePos.left / this.currScale, top: -scenePos.top / this.currScale };
		}
		else {
			return {left: 0, top: 0};
		}
	},
	
	/**
	 * Handle a window resize event. We get this when the screen orientation changes.
	 * 
	 * @param {Event} event
	 */
 	_handleWindowResize: function(event) {
		
		var width = this.controller.window.innerWidth;
		var height= this.controller.window.innerHeight;

		try {
			if (width === this.prevWindowSize.width && height === this.prevWindowSize.height) {
				return;
			}
			
			if (this.adapter.setViewportSize) { // Adapter could be unloaded
				this.adapter.setViewportSize(width, height);
			}
			
			if (this.pluginSpotlightOn) {

				// save viewport info before changing orientation and zooming
				this._pluginSpotlightSaveViewportInfo();

				// use smart zoom to reorient and enlarge plugin under spotlight
				this._clearAutoZoomInfo();
				this._smartZoomCalculateResponseSimple(
					this.pluginSpotlightRect.left, 
					this.pluginSpotlightRect.top, 
					this.pluginSpotlightRect.right, 
					this.pluginSpotlightRect.bottom, 
					0, 0, // centerX, centerY we dont care
					true,  // obsolete "handle"
					false);  // don't run zoom animation during rotation
				this.prevWindowSize.width = width;
				this.prevWindowSize.height = height;
				return;
			}
			// Calculate the current page center before anything is changed.
			var pageTL = this._sceneToPage(this.sceneScroller.getScrollPosition());
			
			// Resize the adapter
			this.currScale = this.currScale * width / this.prevWindowSize.width;
			this._setDimensions(this.adapter, 
						this.currPageWidth * this.currScale, 
						this.currPageHeight * this.currScale);
			
			// Scroll so that the previous center is still in the center of the screen.
			var sceneTL = this._pageToScene(pageTL);
			
			this.sceneScroller.scrollTo(sceneTL.left, sceneTL.top);

			var coordSysChanged = this.prevWindowSize.width === width;
			this.prevWindowSize.width = width;
			this.prevWindowSize.height = height;
		
			if (coordSysChanged) {
				this._clearAutoZoomInfo();
			}
		} catch (e) {
			Mojo.Log.logException(e, '_handleWindowResize');
		}
	},

	/**
	 * @private
	 */
	_clearAutoZoomInfo: function() {
		delete this.lastZoomRectangle;
		this.fitWidth = this.controller.attributes.fitWidth;
		//this.pluginSpotlightRemove();
	},

	_handleDoubleClick: function(event) {
		try {

			if (!this.pageGotSize && this.useAdapter) {
				// disallow user interacxtion before get size
				return;
			}

			if (this.pluginSpotlightOn) {
				Mojo.Log.info("ignoring mojo double click and not triggering a smart zoom");
				return;
			}
			
			this._pluginSpotlightSaveViewportInfo();

			/*
			// plugin spolight handling
			if (this._pluginSpotlightShouldBlockGesture(event)) {
				Mojo.Log.info("_handleDoubleClick(): THIS WILL BE BLOCKED SOON");
				return;
			}
			*/
			
			this._pluginSpotlightTimerReset();

			delete this._lastTapEvent;
			this.pageManipulated = true;

			if ( this.metaViewport &&
					!this.metaViewport.userScalable &&
					!this.userCanAlwaysScale) {
						return;
			}
			
			var scaledPos = Element.viewportOffset(this.adapter);
			scaledPos.left = event.clientX - scaledPos.left;
			scaledPos.top  = event.clientY - scaledPos.top;

			this.smartZoomAtPt(scaledPos.left, scaledPos.top);
		}
		catch (e) {
			Mojo.Log.logException(e, '_handleDoubleClick');
		}
	},

	/**
	 * We save the info for the last element tapped and will only auto-zoom on it
	 * if it is a different element.
	 */
	_sameElementInfoAsPrevTap: function(elementInfo) {
		if (elementInfo) {
			// At present of the two elements have the same bounding box then we 
			// consider them to be the same.
			return this._lastTapElementInfo.bounds &&
				this._lastTapElementInfo.bounds.left == elementInfo.bounds.left &&
				this._lastTapElementInfo.bounds.top == elementInfo.bounds.top &&
				this._lastTapElementInfo.bounds.right == elementInfo.bounds.right &&
				this._lastTapElementInfo.bounds.bottom == elementInfo.bounds.bottom;
		}
		else {
			return false;
		}
	},

	_isZoomableFormElement: function(elementInfo) {
		if (!this.formAutoZoom || (this.metaViewport && !this.metaViewport.userScalable)) {
			return false;
		}
		else if (elementInfo.success) {
			if (elementInfo.isEditable) {
				return true;
			}
			else {
				var element = elementInfo.element.toLowerCase();
				var type = elementInfo.type || "";
				type = type.toLowerCase();
				
				return element === "select" ||
					(element === "input" && type === "radio") ||
					(element === "input" && type === "checkbox");
			}
		}
		else {
			return false;
		}
	},
   
	_handleSingleTap: function(event) {

		try {
			this.tapIndex += 1;
			
			var offset = Element.viewportOffset(this.adapter);

			offset.left = event.centerX - offset.left;
			offset.top  = event.centerY - offset.top;

            // clear pending mousedown highlight timer
            this._clearElementHighlightTimers();
 
			if (this.useAdapter) {
				
				if (this._pluginSpotlightShouldBlockGesture(event)) {
					Mojo.Log.info("_handleSingleTap(): BLOCKING gesture");
					return;
				}

				if (this.pluginSpotlightOn && event.metaKey) {
					Mojo.Log.info("_handleSingleTap(): when in meta mode, ignoring tap");
					return;
				}
				
				
			    
                if (this.trackballMode === false && this.selectionMode === false) {
					this._clearSelection();
			    }
                
				// if mousedown hasn't highlighted us at this point, create highlight
				// we want to add a highlight before clickAt causes webkit to launch redirect apps
				if (!this.isElementHighlighted && this.trackballMode === false && this.selectionMode === false) {
					this._addElementHighlight(event.centerX, event.centerY);
				}
			    
				if (event.altKey) {
					// We do nothing here because we know that the browser uses the alt (Orange) 
					// tap for a menu and doesn't want a browser tap to occur.
					// Once we move the code in this function that controls highlighting to the
					// adapter (where it should be) we can allow applications to capture and stop 
					// the propogation of this event.
					this._clearSelection();

				} else if (event.shiftKey) {
					// Same comment as above. Additionally we send out the modifier tap
					// event for backward compatibility. This event is deprecatetd and 
					// the app should instead observe the 'singletap' event if they want
					// to do something when a modifier key is down.
					
					this.adapter.inspectUrlAtPoint(
						offset.left, 
						offset.top, 
						function(response) {
							Mojo.Event.send(
								this.adapter, 
								Mojo.Event.webViewModifierTap,	
								{linkInfo: response});
						}.bind(this));

				} else {
					
					var elementInfoResponse = function(response) {
						if (this._isZoomableFormElement(response) && !this._sameElementInfoAsPrevTap(response)) {
							this._zoomToFixedDpiThenClick(response);
						}
						else {
							this.adapter.clickAt(response.x, response.y, this.tapIndex);
						}
						this._lastTapElementInfo = response;
					}.bind(this);

					this.elementInfoAtPoint(offset.left, offset.top, elementInfoResponse);
				}

				var removeHighlightWithDelay = function (editing) {
					var delayDuration = 750;  // normal
					if (editing) {
						delayDuration = 250;  // editable element with cursor
					} 
					this.removeElementHighlightTimer = this.controller.window.setTimeout(this._removeElementHighlight, delayDuration);
				}.bind(this);
				this.isEditing(removeHighlightWithDelay);

			} else {
			    // need this delay because at the moment, addElementHighlight 
				// doesn't have a callback, and we can clear BA before BS 
				// returns to BA highlight rects
			    this.removeElementHighlightTimer = this.controller.window.setTimeout(this._removeElementHighlight, 100);
			}
		}
		catch (e) {
			Mojo.Log.logException(e, 'handleSingleTap');
		}
	},

	_deleteLastTapEvent: function() {
		// A hack until NOV-40833 is implemented whereby we will no
		// longer need to save the last tap event.
		delete this._lastTapEvent;
	 },


	_handleTap: function(event) {

		var x = event.down.pageX;
		var y = event.down.pageY;

		if (this.trackballMode) {
			this._enableSelectionMode(x, y);
		}

		// Record current tap event for use in the
		// single tap handler to determine if we should propagate
		// the event to the adapter. Delete after NOV-40833 is implemented.
		this._lastTapEvent = event;
		this.controller.window.setTimeout(this._deleteLastTapEvent, 500);

		// a tap follows a mousedown, so we want to make the mousedown
		// highlight last until tap erases it, and remove any pending erases
	    if (this.removeElementHighlightTimer) {
	        this.controller.window.clearTimeout(this.removeElementHighlightTimer);
	        delete this.removeElementHighlightTimer;
	    }
	    
	},
	
	copy: function(callback) {
		try {
			if (this.useAdapter) {
				this.adapter.copy(callback);
			} else if (typeof(callback) === "function") {
				callback(false);
			}
		} catch (e) {
			Mojo.Log.logException(e, "copy");
		}
	},
	
	paste: function() {
		if (this.useAdapter) {
			this.adapter.paste();
		}
	},
	
	selectAll: function() {
		if (this.useAdapter) {
			this.adapter.selectAll();
		}
	},
	
	handleCommand: function(event) {
		
		var focusedElement = Mojo.View.getFocusedElement(this.controller.scene.sceneElement);

		if (focusedElement != this.adapter) {
			return;
		}
		
		if (event.type === Mojo.Event.commandEnable) {
			switch (event.command) {
				case Mojo.Menu.copyCmd :
				case Mojo.Menu.pasteCmd : 
				case Mojo.Menu.selectAllCmd :
				case Mojo.Menu.cutCmd : 
					event.stopPropagation();
					break;
				default :
					break;
			}

		} else if (event.type === Mojo.Event.command) {
			
			switch (event.command) {
				case Mojo.Menu.copyCmd :
					this.adapter.copy();
					event.stopPropagation();
					break;
				
				case Mojo.Menu.pasteCmd : 
					this.adapter.paste();
					event.stopPropagation();
					break;
				
				case Mojo.Menu.selectAllCmd : 
					this.adapter.selectAll();
					event.stopPropagation();
					break;
				
				case Mojo.Menu.cutCmd :
					this.adapter.cut();
					event.stopPropagation();
					break;
					
				default:
					break;
			}
			
        }
	},

	moved: function(scrollEnding, position) {
            if (this.adapter) {

                // current curve for scrolling is too shallow towards end.
                // we want to inform the adapter much before that
                if (scrollEnding || 
                    (Math.abs(position.x - this.prevScrollPosition.x) < 2 &&
                     Math.abs(position.y - this.prevScrollPosition.y) < 2)) {
                    this.adapter.scrollEnding();
                }
                
                this.prevScrollPosition.x = position.x;
                this.prevScrollPosition.y = position.y;
            }
            
            this._removeElementHighlight();
	},

	_passMouseEvents: function() {
		//return (this.useMouseEvents || this.mouseScrollsNode || this.pluginSpotlightOn);
		return (this.useMouseEvents || this.mouseScrollsNode);
	},

	_handleGestureStart: function(event) {
		if (!this.pageGotSize && this.useAdapter) {
			// disallow user interacxtion before get size
			return;
		}
		Mojo.Log.info("Gesture start: ", event.scale);
		event.stop();

		// currently, gesturestart/change/end do not contain modifiers, so we must
		// keep track of the metakey down and up
		// if carded before up, then this.pluginSpotlightAllowMetaGestures is set to false
		Mojo.Log.info("IN META??????? %s", this.pluginSpotlightAllowMetaGestures);

		// remove link highlights as soon as a gesture starts
		this._removeElementHighlight();

		// plugins spotlight handling
		if (this._pluginSpotlightShouldBlockGesture(event)) {
			Mojo.Log.info("_handleGestureStart(): BLOCKING gesture");
			return;
		}
		this._pluginSpotlightTimerReset();



		this.pageManipulated = true;

		if (this.useAdapter) {
			this.adapter.gestureStart(event.centerX, event.centerY, event.scale, event.rotation, event.centerX, event.centerY);
		}
		
		

		// disallow pinch zoom for google maps, or in partial spotlight mode
		if (this._passMouseEvents() || this.pluginSpotlightMode == "partial" || 
				(this.pluginSpotlightMode == "fullscreen" && !this.pluginSpotlightAllowMetaGestures)) {
			return;
		}
		
		this.zoomAtGestureStart = this.currScale;
		this.offsetAtGestureStart = this.sceneScroller.getScrollPosition();
		this.offsetAtGestureStart.left = event.centerX - this.offsetAtGestureStart.left;
		this.offsetAtGestureStart.top = event.centerY - this.offsetAtGestureStart.top;
		this.inPinchZoom = true;
		this.fitWidth = false;

		var ev = { scale: event.scale,
						   centerX: event.centerX, 
							 centerY: event.centerY };

		this.pinchZoomRecordedScales = [event.scale];
		this.pinchZoomRecordedCenterX = [event.centerX];
		this.pinchZoomRecordedCenterY = [event.centerY];

		this._doPinchZoom(ev);
	},

	_handleGestureChange: function(event) {

		//Mojo.Log.info("Gesture change: ", event.scale);
		event.stop();

		// gestures cancel link highlighting
		this._removeElementHighlight();

		// spotlight handling
		if (this._pluginSpotlightShouldBlockGesture(event)) {
			Mojo.Log.info("_handleGestureChange(): BLOCKING gesture");
			return;
		}
		this._pluginSpotlightTimerReset();


		if (this.useAdapter && (this._passMouseEvents() || (this.pluginSpotlightOn && !this.pluginSpotlightAllowMetaGestures))) {
			// send gesture change events down to adapter only if we are tracking raw mouse events
			// if in spotlight mode, allow raw events only if not in meta mode
			
			Mojo.Log.info("Not performing pinch zoom!");
			
			this.adapter.gestureChange(event.centerX, event.centerY, event.scale, event.rotation,
																 event.centerX, event.centerY);
			return;
		}
		
		Mojo.Log.info("performing pinch zoom");

		// Weighted average of factors to eliminate jitter. This needs to be implemented in the sysmgr
		// gesture generator area
		this.pinchZoomRecordedScales.push(event.scale);
		this.pinchZoomRecordedCenterX.push(event.centerX);
		this.pinchZoomRecordedCenterY.push(event.centerY);
		if (this.pinchZoomRecordedScales.length > this.pinchZoomAvgWeights.length) {
			this.pinchZoomRecordedScales.shift();
			this.pinchZoomRecordedCenterX.shift();
			this.pinchZoomRecordedCenterY.shift();
		}

		var i = 0;
		var numerScale = 0;
		var numerCenterX = 0;
		var numerCenterY = 0;	
		var denom = 0;
		for (i = 0; i < this.pinchZoomRecordedScales.length; i++) {
			numerScale += this.pinchZoomRecordedScales[i] * this.pinchZoomAvgWeights[i];
			numerCenterX += this.pinchZoomRecordedCenterX[i] * this.pinchZoomAvgWeights[i];
			numerCenterY += this.pinchZoomRecordedCenterY[i] * this.pinchZoomAvgWeights[i];
			denom += this.pinchZoomAvgWeights[i];
		}

		var ev = { scale: numerScale / denom,
				   centerX: numerCenterX / denom, 
				   centerY: numerCenterY / denom };

		this._doPinchZoom(ev);
    },

		_handleGestureEnd: function(event) {
			Mojo.Log.info("Gesture end: ", event.scale);
			event.stop();

			Mojo.Log.info("IN META??????? %s", this.pluginSpotlightAllowMetaGestures);
			// plugin spotlight handling
			if (this._pluginSpotlightShouldBlockGesture(event)) {
				Mojo.Log.info("_handleGestureChange(): BLOCKING gesture");
				return;
			}
			this._pluginSpotlightTimerReset();
			
			
			this.inPinchZoom = false;
			if (this.useAdapter) {
				this.adapter.gestureEnd(event.centerX, event.centerY, event.scale, event.rotation,
					event.centerX, event.centerY);
			}
			/*
			if (this._passMouseEvents()) {
				return;
			}
			*/
		},

    _doPinchZoom: function(event) {
    
        var eventScale = event.scale;
        var eventCenterX = event.centerX;
        var eventCenterY = event.centerY;

        // Round off event at two decimals. reduces jitter    
        eventScale = Math.round(event.scale * 100) / 100;
            
        var scaleFactor = this.zoomAtGestureStart * eventScale;
        if (scaleFactor > this.maxScaleFactor) {
            // It's possible that our current scale factor is < maxScaleFactor and the new one would bring it
            // to > maxScaleFactor instead of bringing us exactly to maxScaleFactor and that leaving now
            // will leave the current scale factor at something less then maxScaleFactor. However generally we'll
            // be really close to maxScaleFactor and this is an easy solution that should be unnoticed
            // by the user.
            scaleFactor = this.maxScaleFactor;
        }

        if (this.metaViewport && !this.userCanAlwaysScale) {
            if (!this.metaViewport.userScalable) {
                return;
            }
            if (scaleFactor > this.metaViewport.maximumScale) {
                return;
            }
            if (scaleFactor < this.metaViewport.minimumScale) {
                return;
            }
        }

        // will this zoom level cause the zoomed width to become smaller
        // than our window width
        var scaledWidth = Math.round(this.currPageWidth * scaleFactor);
        var scaledHeight = Math.round(this.currPageHeight * scaleFactor);

        this.currScale = scaledWidth / this.currPageWidth;
        eventScale = this.currScale / this.zoomAtGestureStart;

        if (scaledWidth < this.controller.window.innerWidth) {
            // yes, don't change the scale factor but allow tracking to occur
            scaleFactor = this.controller.window.innerWidth / this.currPageWidth;
            scaledWidth = Math.round(this.currPageWidth * scaleFactor);
            scaledHeight = Math.round(this.currPageHeight * scaleFactor);

            this.currScale = scaleFactor;
            eventScale = this.currScale / this.zoomAtGestureStart;
        }

        var scrollX = Math.round(this.offsetAtGestureStart.left * eventScale) - eventCenterX;
        var scrollY = Math.round(this.offsetAtGestureStart.top * eventScale) - eventCenterY;

        if (scrollX < 0) {
            scrollX = 0;
        }
        else if ((scrollX + scaledWidth) < this.controller.window.innerWidth) {
            scrollX = this.controller.window.innerWidth - (scrollX + scaledWidth);
        }

        if (scrollY < 0) {
            scrollY = 0;
        }

        try {
            var lb = parseInt(this.adapter.getStyle('border-left-width'), 10);
            var rb = parseInt(this.adapter.getStyle('border-right-width'), 10);

            scaledWidth = scaledWidth + lb + rb;

            this._setDimensions(this.adapter, scaledWidth, scaledHeight);

            this.sceneScroller.scrollTo(-scrollX, -scrollY);
        }
        catch (e) {}
     },

    _handleDragStart: function(event) {
			if (!this.pageGotSize && this.useAdapter) {
				// disallow user interacxtion before get size
				return;
			}
			this.pageManipulated = true;
			Mojo.Log.info("drag start");

			if (this.inPinchZoom || this._passMouseEvents() || 
				this.pluginSpotlightMode == "fullscreen" && !event.move.metaKey ||
				this.pluginSpotlightMode == "partial") {
					//Mojo.Log.info("preventing drag... inPinchZoom: %s, meta key: %s", this.inPinchZoom, event.move.metaKey);
				event.stop();
			}

			// no highlighting during drags
			this._removeElementHighlight();

		},
		
    _addAsScrollListener: function(event) {
        event.scroller.addListener(this);
        if (this.adapter) {
            this.adapter.scrollStarting();
        }
    },


	_handleMouseDown: function(event) {
		if (this.adapter && (this._passMouseEvents() || this.pluginSpotlightOn)) {

			// plugin spotlight handling
			if (this._pluginSpotlightShouldBlockGesture(event)) {
				Mojo.Log.info("_handleMouseDown(): blocking raw event");
				return;
			}	
			
			// never send raw events in spotlight mode when meta is down
			if (event.metaKey) {
					//Mojo.Log.info("_handleMouseDown(): blocking raw event because of META");
					return;
			}
			
			this._mousemoveThrottleReset();  // used to stop identical mousemove events
			
			this._pluginSpotlightTimerDelete();

			if (this.mouseScrollsNode) {
				this.adapter.setMouseMode(Mojo.WebView.MouseModeScroll);
			}
			else {
				this.adapter.setMouseMode(Mojo.WebView.MouseModeSelect);
			}
			var offset = Element.viewportOffset(this.adapter);
			offset.left = event.x - offset.left;
			offset.top  = event.y - offset.top;
			this.adapter.mouseEvent(this.mouseDownEventType, offset.left, offset.top, event.detail);
		}
	},
	
	_mousemoveThrottleSaveEvent: function(event) {
		this._lastMousemoveEvent = event;
	},
	
	_mousemoveThrottleReset: function() {
		this._lastMousemoveEvent = undefined;
	},

	_mousemoveThrottleShouldStopEvent: function(event) {
		if (this._lastMousemoveEvent !== undefined &&
			  this._lastMousemoveEvent.type == event.type &&
				this._lastMousemoveEvent.x == event.x &&
				this._lastMousemoveEvent.y == event.y) {
					return true;
		}
				
		return false;
	},

	_clearSelection: function() {
		try {
			// don't want to clear selection unless this is run at least 350ms 
			// after shift was raised/selection mode was turned off
			var timeSinceSelectionCreation = Date.now() - this.selectionDisabledTime;
			if (timeSinceSelectionCreation > 350) {
				this.adapter.clearSelection();	
				Mojo.Log.info("clearing selection because time difference is " + timeSinceSelectionCreation);
			} else {
				Mojo.Log.info("NOT clearing selection because time difference is " + timeSinceSelectionCreation);
			}
		} catch (e) {}
	},
	
	_handleMouseUp: function(event) {

		if (this.adapter && (this._passMouseEvents() || this.pluginSpotlightOn)) {
			
			if (this._pluginSpotlightShouldBlockGesture(event)) { 
				Mojo.Log.info("_handleMouseUp(): blocking event");				
				return;
			} 
			
			// never send raw events when in spotlight mode when meta is down
			if (event.metaKey) {
				//Mojo.Log.info("_handleMouseUp(): blocking raw event because of META");				
				return;
			}
			
			this._mousemoveThrottleReset();

			this._pluginSpotlightTimerReset();
			
			var offset = Element.viewportOffset(this.adapter);
			offset.left = event.x - offset.left;
			offset.top  = event.y - offset.top;
			this.adapter.mouseEvent(this.mouseUpEventType, offset.left, offset.top, event.detail);
		}
		this.adapter.setMouseMode(Mojo.WebView.MouseModeSelect);
	},

	_handleMouseMove: function(event) {
		if (this.adapter && (this._passMouseEvents() || this.pluginSpotlightOn)) {

			if (this._pluginSpotlightShouldBlockGesture(event)) {
				Mojo.Log.info("_handleMouseMove(): blocking event");
				return;
			}	

			// never send raw events when in spotlight mode when meta is down
			if (event.metaKey) {
				return;
			}
			
			this._pluginSpotlightTimerDelete();
			
			if (this._mousemoveThrottleShouldStopEvent(event)) {
				return;
			}
			
			this._mousemoveThrottleSaveEvent(event);
			
			var offset = Element.viewportOffset(this.adapter);
			offset.left = event.x - offset.left;
			offset.top  = event.y - offset.top;
			this.adapter.mouseEvent(this.mouseMoveEventType, offset.left, offset.top, event.detail);
		}
	},


		// Highlight links, text boxes, buttons
    
    _handleMouseDownHighlight: function(event) {
        if (this.selectionMode === false && this.trackballMode === false) {
            var addElementHighlight = this._addElementHighlight.bind(this, event.x, event.y);
            Mojo.Log.info("_handleMouseDownHighlight, with 150ms delay: x: %d, y: %d", event.x, event.y);
            this.addElementHighlightTimer = this.controller.window.setTimeout(addElementHighlight, 150);
        }
    },

    _handleMouseUpHighlight: function(event) {
	    this.removeElementHighlightTimer = this.controller.window.setTimeout(this._removeElementHighlight, 350);
    },

    _handleMouseMoveHighlight: function(event) {
        this._removeElementHighlight();            
    },


		// Plugin Spotlight 

		// Hold event creates partial plugin spotlight
		_handleHoldPluginSpotlight: function(event) {

			if (this.pluginSpotlightOn && (this.pluginSpotlightMode == "fullscreen" || this.pluginSpotlightMode == "partial")) {
					this._pluginSpotlightTimerDelete();
					return;
			}

			// test if a target is an <object>, <embed>, or <applet> element
			// if it is, assume it is something that can accept raw mouse events
			// and put webview into spotlight mode
			
			var offset = Element.viewportOffset(this.adapter);
			offset.left = event.down.pageX - offset.left;
			offset.top  = event.down.pageY - offset.top;

			// callback fired adapter after it examines target of hold coords
			// note: mousedown is sent after partial spotlight is created
			var startPartialSpotlight = function(event, elementInfo) {

				var element = elementInfo.element.toLowerCase();
				var type = elementInfo.type || "";
				type = type.toLowerCase();

				if (element == "object" || element == "embed" || element == "applet") {
						Mojo.Log.info("bounding box: %d, %d, %d, %d", 
							elementInfo.bounds.left, elementInfo.bounds.top, 
							elementInfo.bounds.right, elementInfo.bounds.bottom);
						
						this._pluginSpotlightCreate(elementInfo.bounds, "partial", true);

						var offset = Element.viewportOffset(this.adapter);
						offset.left = event.down.pageX - offset.left;
						offset.top  = event.down.pageY - offset.top;
						
						Mojo.Log.info("event types: this.mouseDownEventType=%d, offset.left=%d, offset.top=%d, detail=%d",
						this.mouseDownEventType, offset.left, offset.top, event.down.detail);

						this.adapter.mouseEvent(this.mouseDownEventType, offset.left, offset.top, event.down.detail);
				}
			}.bind(this, event);

			this.elementInfoAtPoint(offset.left, offset.top, startPartialSpotlight);

		},

		_handleKeyDownPluginSpotlight: function(event) {
			if (this.pluginSpotlightOn && this.pluginSpotlightMode == "fullscreen") {
				if (event.keyCode == Mojo.Char.metaKey) {
					Mojo.Log.info("_handleKeyDownPluginSpotlight(): entering spotlight app control mode");
					this.pluginSpotlightAllowMetaGestures = true;
				}
				
				if (event.keyCode == Mojo.Char.pageDown || event.keyCode == Mojo.Char.pageUp || 
					event.keyCode == 179 || event.keyCode == 180) {  // desktop build constants
					this.pluginSpotlightRemove(true);  // true to notify client
					event.stop();
				}
			}
		},

		_handleKeyUpPluginSpotlight: function(event) {
			if (this.pluginSpotlightOn && event.keyCode == Mojo.Char.metaKey && this.pluginSpotlightMode == "fullscreen") {
				Mojo.Log.info("_handleKeyUpPluginSpotlight(): exiting spotlight app control mode");
				this.pluginSpotlightAllowMetaGestures = false;
			}
		},

		_handleMouseUpPluginSpotlight: function(event) {

			Mojo.Log.info("_handleMouseUpPluginSpotlight(): hold ended");
			
			switch (this.pluginSpotlightMode) {
				case "fullscreen" :
					Mojo.Log.info("not removing spotlight");
					
					break;					

				case "partial" :
					  var removeDelayMs = 500;
						Mojo.Log.info("removing spotlight in %d ms", removeDelayMs);
						
						this._pluginSpotlightTimerDelete();
			
						var spotlightRemove = this.pluginSpotlightRemove.bind(this);
						this.pluginSpotlightRemoveTimer = this.controller.window.setTimeout(spotlightRemove, removeDelayMs);
						
						break;						
						
				default :
					break;
			}
		},
		
		// used by plugins via browser adapter to put webview and its client into spotlight mode
		pluginSpotlightCreate: function(left, top, right, bottom, mode, notifyWebviewClient) {

			if (mode == "fullscreen") {
				
				// we're about to zoom into a plugin, so preserve current viewport for restore
				this._pluginSpotlightSaveViewportInfo();
				
				// FIXME: stop piggybacking off the mysterious animation code provided by smart zoom
				// and isolate it into one animation function that will be called here and by smart zoom
				this._smartZoomCalculateResponseSimple(left, top, right, bottom, 0, 0, true, true);
				
			} else {
				var spotlightRect = {left : left, top : top, right : right, bottom : bottom};
				this._pluginSpotlightCreate(spotlightRect, mode, notifyWebviewClient);
			}
			
		},

		_pluginSpotlightCreate: function(spotlightRect, mode, notifyWebviewClient) {
			
			if (!this.useAdapter) {
				return;
			}

			// // prevent raw mouse events from creating a selection when a plugin doesn't handle them
			// 			this.adapter.setUserSelect(false);
			
			// clear timer that was intended to remove spotlight
			this._pluginSpotlightTimerDelete();

			if (notifyWebviewClient === undefined) {
				notifyWebviewClient = true;
			}
			
			this.pluginSpotlightOn = true;
			this.pluginSpotlightMode = mode;
			
			// save rect of spotlight for gesture blocking
			this.pluginSpotlightRect = spotlightRect;

			var scrimAlpha = 0;
			
			switch (mode) {
				case "fullscreen" :
					scrimAlpha = this.pluginSpotlightScrim.fullscreen;
					break;
				case "partial" :
					scrimAlpha = this.pluginSpotlightScrim.partial;
					break;
				default :
					scrimAlpha = 255;
				  break;
			}

			Mojo.Log.info("_pluginSpotlightCreate(): rect left: %d, top: %d, bottom: %d, right: %d, alpha: %d", spotlightRect.left, 
				spotlightRect.top, 
				spotlightRect.right, 
				spotlightRect.bottom, scrimAlpha);
			
			this.adapter.setSpotlight(spotlightRect.left, 
				spotlightRect.top, 
				spotlightRect.right, 
				spotlightRect.bottom, 
				1,  // argument is redundant and will be removed
				scrimAlpha);

			if (notifyWebviewClient) {
				Mojo.Event.send(this.adapter, Mojo.Event.webViewPluginSpotlightStart, {});
			}
			
		},
		
		_pluginSpotlightSaveViewportInfo: function() {

			Mojo.Log.info("_pluginSpotlightSaveViewportInfo(): saving scale, scroll pos");
			this.pluginSpotlightViewportAtStart.canRestore = true;
			
			this.pluginSpotlightViewportAtStart.scale = this.currScale;
			this.pluginSpotlightViewportAtStart.scrollPos = this.sceneScroller.getScrollPosition();

			var pageDimensions = this.adapter.getDimensions();				
			this.pluginSpotlightViewportAtStart.width = pageDimensions.width;
			this.pluginSpotlightViewportAtStart.height = pageDimensions.height;
		},
		
		_pluginSpotlightRestoreViewport: function() {

			if (this.pluginSpotlightViewportAtStart.canRestore === false) {
				Mojo.Log.info("_pluginSpotlightRestoreViewport(): not performing double restore");
				return;
			}
			
			Mojo.Log.info("_pluginSpotlightRestoreViewport(): restoring viewport after spotlight");
			
			this.pluginSpotlightViewportAtStart.canRestore = false;
			
			// haven't gotten smartzoom to work with restoring viewport just yet -ad
			//
			// var centerX = (this.pluginSpotlightViewportAtStart.scrollPos.left + this.pluginSpotlightViewportAtStart.width)/2.0
			// var centerY = (this.pluginSpotlightViewportAtStart.scrollPos.top + this.pluginSpotlightViewportAtStart.height)/2.0;

			// this._clearAutoZoomInfo();
			// var zoomFitWidth = this.fitWidth;
			// this.fitWidth = false;
			// this._smartZoomCalculateResponseSimple(this.pluginSpotlightViewportAtStart.scrollPos.left, 
			// 	this.pluginSpotlightViewportAtStart.scrollPos.top, this.pluginSpotlightViewportAtStart.width, this.pluginSpotlightViewportAtStart.height,
			// 	//centerX, centerY, false, true);
			// 	0, 0, false, true);
			// this.fitWidth = zoomFitWidth;

			// we went into spotlight mode via smart zoom, and left some states behind that need to be cleared
			this._clearAutoZoomInfo();
			
			this.currScale = this.pluginSpotlightViewportAtStart.scale;
			this.adapter.setMagnification(this.pluginSpotlightViewportAtStart.scale);
			
			this._setDimensions(this.adapter, 
				this.pluginSpotlightViewportAtStart.width,
				this.pluginSpotlightViewportAtStart.height);
			
			this.sceneScroller.scrollTo(this.pluginSpotlightViewportAtStart.scrollPos.left,
				this.pluginSpotlightViewportAtStart.scrollPos.top);
		},
		
		// only partial spotlight uses a timer
		_pluginSpotlightTimerReset: function() {
			if (this.pluginSpotlightOn && this.pluginSpotlightMode == "partial") {
				this._pluginSpotlightTimerDelete();
				var spotlightRemove = this.pluginSpotlightRemove.bind(this);
				this.pluginSpotlightRemoveTimer = this.controller.window.setTimeout(spotlightRemove, 500);
			}
		},
		
		_pluginSpotlightTimerDelete: function() {
			if (this.pluginSpotlightRemoveTimer) {
				this.controller.window.clearTimeout(this.pluginSpotlightRemoveTimer);
      	delete this.pluginSpotlightRemoveTimer;
			}
		},

		_pluginSpotlightReleaseGestures: function() {
			Mojo.Log.info("_spotlightReleaseGestures(): allowing gestures to go through to app");
		},
		
		
		_pluginSpotlightWillCreate: function(mode) {
			this.pluginSpotlightOn = true;
			this.pluginSpotlightMode = mode;

			// // prevent raw mouse events from creating a selection on an unloaded
			// // plugin, or on a plugin that doesn't handle these events
			// this.adapter.setUserSelect(false);
		},

		pluginSpotlightRemove: function(notifyWebviewClient) {

			Mojo.Log.info("pluginSpotlightRemove(): removing plugin spotlight");
			
			// stop painting scrim
			if (this.pluginSpotlightOn) {
				this.adapter.removeSpotlight();
			}

			this.pluginSpotlightOn = false;

			// restore zoom and scroll position
			if (this.pluginSpotlightMode == "fullscreen") {

				this.pluginSpotlightMode = "invalid";
				var restoreViewport = this._pluginSpotlightRestoreViewport.bind(this);
				this.controller.window.setTimeout(restoreViewport, 100);
				
				//this._pluginSpotlightRestoreViewport();
			}

			this.pluginSpotlightMode = "invalid";
			this.pluginSpotlightRect = undefined;
			this.pluginSpotlightAllowMetaGestures = false;

			if (notifyWebviewClient === undefined || notifyWebviewClient) {
				Mojo.Log.info("pluginSpotlightRemove(): sending up spotlightEnd event");
				Mojo.Event.send(this.adapter, Mojo.Event.webViewPluginSpotlightEnd, {});
			} else {
				Mojo.Log.info("pluginSpotlightRemove(): not sending spotlightEnd event to client");
			}

			// // in spotlightCreate, we disabled selection in document
			// this.adapter.setUserSelect(true);

		},

		_pluginSpotlightShouldBlockGesture: function(event) {
			
			if (!this.pluginSpotlightOn || !this.useAdapter) {
				return false;
			}

			// never reject gestures when meta key is down
			if (event.metaKey || this.pluginSpotlightAllowMetaGestures) {
				Mojo.Log.info("_pluginSpotlightShouldBlockGesture(): skipping meta");
				return false;
			}
			
			var scaledPos = Element.viewportOffset(this.adapter);
			var x = event.pageX - scaledPos.left;
			var y = event.pageY - scaledPos.top;
			
			return !this._inPluginSpotlight(x,y);  // block events outside of spotlight

		},

	  _inPluginSpotlight: function(x, y) {
		
			if (!this.pluginSpotlightOn || this.pluginSpotlightRect === undefined) {
				Mojo.Log.info("_inPluginSpotlight(): not in spotlight mode or spotlight rect undefined");
				return false;
			}
			
			Mojo.Log.info("_inPluginSpotlight(): x: %d, y: %d, currScale: %d", x, y, this.currScale);

			return (x >= this.pluginSpotlightRect.left * this.currScale && 
				x < this.pluginSpotlightRect.right * this.currScale && 
				y >= this.pluginSpotlightRect.top * this.currScale && 
				y < this.pluginSpotlightRect.bottom * this.currScale);		
		},

		// Text Selection
		
    _enableSelectionMode: function(x, y) {
        if (!this.trackballMode) {
            return;
        }
        
        try {
            if (this.adapter) {
                Mojo.Log.info("enabling selection via BrowserAdapter");
                this.adapter.enableSelectionMode(x, y);  // x, y are scaled by adapter
                this.selectionMode = true;
            }
        } catch (e) {
            Mojo.Log.logException(e, "_enableSelectionMode");
        }
    },
    
    _disableSelectionMode: function() {
        try {
            if (this.adapter) {
                Mojo.Log.info("disabling selection via BrowserAdapter");

				// delay disabling selection 250 ms when user lifts shift/disables selection mode
				// during the drawing of the reticle but before the tap event comes in.
				// If tap event comes in after selectionMode is set to false, then
				// selection will be cleared, which is likely to be unintentional.

				var delayedDisable = function () {
					if (this.adapter) {
						this.adapter.disableSelectionMode();
					}
					this.selectionMode = false;
				}.bind(this);

				this.controller.window.setTimeout(delayedDisable, 250);

				// suppress clearance that comes in after shift is lifted
				this.selectionDisabledTime = Date.now();
            }
        } catch (e) {
            Mojo.Log.logException(e, "_disableSelectionMode");
        }
    },
    
    _handleKeyDownTrackball: function(event) {
        // Mojo.Log.info("WIDGET SEES KEY event which=%d, modifiers=%d, keycode=%d", event.which, event.modifiers, event.keyCode);        
        if (event.keyCode == Mojo.Char.shift) {  // 16 for simulator, 0 for arm
            Mojo.Log.info("turning ON trackball");
            this.trackballMode = true;
        } 
    },
    
    _handleKeyUpTrackball: function(event) {
        if (event.keyCode == Mojo.Char.shift) {
            Mojo.Log.info("turning OFF trackball");
            this._disableSelectionMode();
            this.trackballMode = false;
        }
    },
  
    _handleKeyDownHighlight: function(event) {
		// clear editable text field highlight as soon as user enters text
        this._removeElementHighlight();
    },
    
    _addElementHighlight: function(x, y) {
	
        // not adding highlights if in trackball mode
        if (this.trackballMode) {
            return;
        }

				if (this.pluginSpotlightOn) {
					return;
				}

        this._clearElementHighlightTimers();

        this._removeElementHighlight();  // also clears timers

	    if (this.adapter) {
	        this.adapter.addElementHighlight(x, y);
	        this.isElementHighlighted = true;
	    }

    },
    
    _removeElementHighlight: function() {

        this._clearElementHighlightTimers();

	    if (this.isElementHighlighted && this.adapter) {
	        Mojo.Log.info("REMOVING element highlight");
		    this.adapter.removeElementHighlight();		    
		    this.isElementHighlighted = false;
	    }

    },
    
    _clearElementHighlightTimers: function() {
        
	    if (this.addElementHighlightTimer) {
		    this.controller.window.clearTimeout(this.addElementHighlightTimer);
		    delete this.addElementHighlightTimer;
	    } 
	    
	    if (this.removeElementHighlightTimer) {
            this.controller.window.clearTimeout(this.removeElementHighlightTimer);
            delete this.removeElementHighlightTimer;
        }
    },
    
    // scrollTo callback from the JS side
    scrollTo: function(x, y) {
        Mojo.Log.info("Scrolled to: %d x %d", x, y);
		this.sceneScroller.scrollTo(-x, -(y + this.topMargin));
    },

	/**
	 * Set the top margin (in pixels)
	 * @param {Number} margin
	 */
	setTopMargin: function(margin) {
		
		this.topMargin = margin;
	},
	
	/**
	 * Called by the adapter whenever a URL has been redirected.
	 */
	urlRedirected: function(url, userData) {
		
		url = this.$X(url);

		Mojo.Log.info("Got URL redirect: '%s' -> '%s'", url, userData);
        Mojo.Event.send(this.adapter, Mojo.Event.webViewUrlRedirect, 
			{url: url, appId: userData});
	},

	_addRedirects: function(table, type, skipAppId) {
		for (var i = 0; i < table.length; i++) {

			var entry = table[i];

			if (skipAppId && skipAppId == entry.appId) {
				continue;
			}

			try {
				this.addUrlRedirect(entry.url, true, entry.appId, type);
			}
			catch (e) {
				Mojo.Log.logException(e, "Failure adding redirect rule '%s' -> '%s'", entry.url, entry.appId);
			}
		}
	},

	/**
	 * Read the command resource handler table and send down redirect handler 
	 * commands to the browser server.
	 */
	addSystemRedirects: function(skipAppId) {
		var restable = Mojo.loadJSONFile("/usr/palm/command-resource-handlers.json");
		this._addRedirects(restable.redirects, 0, skipAppId);
		this._addRedirects(restable.commands, 1, skipAppId);
	},

    // pageDimensions callback from the JS side
    pageDimensions: function(width, height) {
		var curScale, minScale;
        //Mojo.Log.info("Page dimensions changed: %d x %d", width, height);
            
		if (width === 0 || height === 0) {

			// reset fit width and scroll positions. FIXME: use history when its ready
			this.currScale = 1.0;
			this.currPageWidth = 0;
			this.currPageHeight = 0;
			delete this.metaViewport;
			this._clearAutoZoomInfo();
			this.sceneScroller.scrollTo(0, -this.topMargin);

			this._setDimensions(this.adapter, this.controller.window.innerWidth, this.controller.attributes.virtualpageheight);
			return;
		}
		this.pageGotSize = true;

        width = width > this.controller.window.screen.width ? width : this.controller.window.screen.width;
        height = height > this.controller.attributes.minimumpageheight ? height :
			this.controller.attributes.minimumpageheight;
		this.currPageWidth = width;
		this.currPageHeight = height;

		minScale = this.controller.window.innerWidth / width;
		if (this.metaViewport) {
			curScale = Math.max(this.metaViewport.initialScale, minScale);

		} else if (this.fitWidth && !this.pageManipulated) {
		 	curScale = minScale;
		}

		if (curScale !== undefined) {
			this.currScale = Math.max(curScale, this.minScaleFactor);
			if (this.useAdapter) {
				this.adapter.setMagnification(this.currScale);
			}
		}

		this._setDimensions(this.adapter,
				this.currPageWidth * this.currScale, 
				this.currPageHeight * this.currScale);

		if (this.fitWidth && !this.pageManipulated) {
			this._restoreCurrentPagePosition();
		}
    },

	metaViewportSet: function(initialScale, minimumScale, maximumScale,
							  width, height, userScalable) {
		Mojo.Log.info("MetaViewport: scale: %d, %d, %d, dims: %d, %d, userScalable: %d",
					  initialScale, minimumScale, maximumScale,
					  width, height, userScalable);

		this.metaViewport = new Mojo.WebView.MetaViewport(initialScale, minimumScale, maximumScale,
														  width, height, userScalable);

		this.currScale = initialScale;
		if (this.useAdapter) {
			this.adapter.setMagnification(this.currScale);
		}

		this._setDimensions(this.adapter,
							this.currPageWidth * this.currScale,
							this.currPageHeight * this.currScale);
	},

    titleURLChange : function(title, url, canGoBack, canGoForward) {

		title = this.$X(title);
		url = this.$X(url);

		this.isAutoZoomed = false;
		this.lastUrl = url;
		this.loadingUrl = null;
        Mojo.Event.send(this.adapter, Mojo.Event.webViewTitleUrlChanged, 
			{title: title, url: url, canGoBack:canGoBack, canGoForward:canGoForward});
    },

	titleChanged: function(title) {

		title = this.$X(title);

		this.isAutoZoomed = false;
		Mojo.Event.send(this.adapter, Mojo.Event.webViewTitleChanged, {title: title});	
    },
	
	urlChange: function(url, canGoBack, canGoForward) {
        
		url = this.$X(url);

		this.lastUrl = url;
		this.isAutoZoomed = false;	
		Mojo.Event.send(this.adapter, Mojo.Event.webViewUrlChanged, 
			{url: url, canGoBack:canGoBack, canGoForward:canGoForward});	
    },

	/**
	 * Zoom into the specified element.
	 */
	_zoomToFixedDpiThenClick: function(elementInfo) {
		//Mojo.Log.info("_zoomToFixedDpiThenClick (%d, %d) on <%s>", elementInfo.x, elementInfo.y, elementInfo.element);

		if (Math.abs(this.formAutoZoomScaleFactor - this.currScale) < 0.01) {
			this.adapter.clickAt(elementInfo.x, elementInfo.y, 1);
		}
		else {
			// Calculate the desired document point that we want to zoom to (in document coords).
			var centerX;
			var centerY = (elementInfo.bounds.top + elementInfo.bounds.bottom) / 2.0;
			var boundsWidth = elementInfo.bounds.right - elementInfo.bounds.left;
			if (boundsWidth * this.formAutoZoomScaleFactor > this.controller.window.innerWidth) {
				// After zooming in the element will be too wide to fit in the screen
				// so instead zoom so that the left edge of the item is on the left side
				// of the screen.
				centerX = elementInfo.bounds.left + 
					(this.controller.window.innerWidth/
					 this.formAutoZoomScaleFactor) / 2.0;
			}
			else {
				centerX = (elementInfo.bounds.left + elementInfo.bounds.right) / 2.0;
			}

			// Now calculate the rectangle that we will zoom to once scaled.
			var finalZoomWidth  = this.controller.window.innerWidth  / this.formAutoZoomScaleFactor;
			var finalZoomHeight = this.controller.window.innerHeight / this.formAutoZoomScaleFactor;
			var finalZoomLeft = centerX - finalZoomWidth /2.0;
			var finalZoomTop  = centerY - finalZoomHeight/2.0;

			var zoomRect = new Mojo.WebView.Rectangle(finalZoomLeft, finalZoomTop,
						finalZoomLeft + finalZoomWidth, finalZoomTop + finalZoomHeight);

			// Clamp the desired zoom rectangle to the document size because if we don't
			// then smartZoomCalculateResponseSimple will - and it will do so by adjusting the
			// scale which results in odd animated zooms when clicking between form elements
			// near the borders of the page.
			if (zoomRect.left < 0) {
				zoomRect.offset(-zoomRect.left, 0);
			}
			else if (zoomRect.right >= this.currPageWidth) {
				zoomRect.offset(1+this.currPageWidth - zoomRect.right, 0);
			}
			if (zoomRect.top < 0) {
				zoomRect.offset(0, -zoomRect.top );
			}
			else if (zoomRect.bottom >= this.currPageHeight) {
				zoomRect.offset(0, 1+this.currPageHeight - zoomRect.bottom);
			}

			// Clear last zoom rectangle so that smartZoomCalculateResponseSimple
			// doesn't fit-to-screen the page.
			this.lastZoomRectangle = null;
			// Remove scale factor so that after we change to a new scale factor we can
			// recalcualte it.
			this._postAnimClickPt = {
				x:elementInfo.x / this.currScale,
				y:elementInfo.y / this.currScale};

			this.smartZoomCalculateResponseSimple(zoomRect.left, zoomRect.top,
					zoomRect.right, zoomRect.bottom, centerX, centerY, false);
		}
	},

     smartZoomCalculateResponseSimple: function(left, top, right, bottom, centerX, centerY, spotlightHandle) {
     	// get response from BA, run smart zoom with animation
     	this._smartZoomCalculateResponseSimple(left, top, right, bottom, centerX, centerY, spotlightHandle, true);
     },
        
     _smartZoomCalculateResponseSimple: function(left, top, right, bottom, centerX, centerY, spotlightHandle, runAnimation) {        
 
        try {
            Mojo.Log.info('Smart Zoom response pt:(%d,%d) r: L:%d, T:%d, R:%d, B:%d',
						  centerX, centerY, left, top, right, bottom);
            
            var rectW = right - left;
            var rectH = bottom - top;
            
            if (rectW <= 0 || rectH <= 0) {
                Mojo.Log.info("Smart zoom failed");
                return;
            }
            
            var newZoomRectangle = new Mojo.WebView.Rectangle(left, top, right, bottom);
            
            if (spotlightHandle === false) {
	            var marginX = (rectW * this.smartZoomScaleSlopFactor - rectW) / 2;
    	        var marginY = (rectH * this.smartZoomScaleSlopFactor - rectH) / 2;
	            left -= marginX;
	            right += marginX;
	            top -= marginY;
	            bottom += marginY;
            }
            
            left = Math.max(left, 0);
            top = Math.max(top, 0);
            right = Math.min(right, this.currPageWidth);
            bottom = Math.min(bottom, this.currPageHeight);
            
            var newScale;
			var zoomLeft;
			var zoomTop;
			var newScaleHorizontal = this.controller.window.innerWidth / (right - left);
			var newScaleVertical = this.controller.window.innerHeight / (bottom - top);
			if (spotlightHandle !== false) {
				// for lock area, we fit it to window
				if (newScaleHorizontal<newScaleVertical) {
					// fit width, center lock area vertically
					newScale = newScaleHorizontal;
					zoomLeft = Math.floor(left * newScale);
					zoomTop = top*newScale - (this.controller.window.innerHeight - (bottom-top)*newScale) / 2;
				} else {
					// fit height, center lock area horizontally
					newScale = newScaleVertical;
					zoomTop = Math.floor(top * newScale);
					zoomLeft = left*newScale - (this.controller.window.innerWidth - (right-left)*newScale) / 2;
				}
			} else {
				// else, we fit it to width and centerY to click center
				newScale = newScaleHorizontal;
				zoomLeft = Math.floor(left * newScale);
				zoomTop = centerY * newScale - this.controller.window.innerHeight / 2;
			}
            
            var currScrollPos = this.sceneScroller.getScrollPosition();
            // Negate the scroll position to get the more "conventional" scroll offset definition
            currScrollPos = { left: -currScrollPos.left, top: -currScrollPos.top };

            // comparing left & scale is equal to comparing left & right
						if (!this.pluginSpotlightOn && spotlightHandle!==true && 
							this.lastZoomRectangle && this.lastZoomRectangle.equals(newZoomRectangle) &&
							currScrollPos.left === zoomLeft && Math.abs(newScale - this.currScale) < 0.00001) {
            
                // Same zoom results as before and we're at the same horizontal position so fit to page.

                // Resize page back to fit screen width
                newScale = this.controller.window.innerWidth / this.currPageWidth;

                // Fit width, so snap to left edge of page
                zoomLeft = 0;

                // Center vertically around the current centerY position
								zoomTop = centerY * newScale - this.controller.window.innerHeight / 2;

                // Make sure the zoomTop doesn't underflow or overflow
                if (zoomTop < 0) {
                    zoomTop = 0;
                }
                else if (zoomTop > (this.currPageHeight * newScale - this.controller.window.innerHeight)) {
                    zoomTop = this.currPageHeight * newScale - this.controller.window.innerHeight;
                }
                
                this._clearAutoZoomInfo();
            }
						else {

							// we need to fit the smartzoom rect to window horizontally and center around the Y location
							this.fitWidth = false;
							
							if (spotlightHandle) {
								this._pluginSpotlightWillCreate("fullscreen");
							}
						}
						
						if (!runAnimation) {
							Mojo.Log.info("############### scale: %d, page width: %d, page height: %d", newScale, this.currPageWidth, this.currPageHeight);
							this.currScale = newScale;
							this._setDimensions(this.adapter, this.currScale * this.currPageWidth, this.currScale * this.currPageHeight);
							this.sceneScroller.scrollTo(-zoomLeft, -zoomTop);
							this.lastZoomRectangle = newZoomRectangle;
							if (spotlightHandle) {
								this._pluginSpotlightCreate(this.lastZoomRectangle, "fullscreen", true);
							}
							return;
						}

            this.inPinchZoom = true;
            
            // ------------------------------------------------------------------------------------

            // Algo is: find where the target viewport rectangle maps to with the current scale and make sure
            // the zoom is such that the mapped viewport topLeft animates linearly to the target viewport topLeft

            this.szTargetScale = newScale;
            this.szTargetOffsetOrigin = { left: zoomLeft, top: zoomTop };
            this.szTargetOffsetViewport = { left: 0, top: 0 };

            this.szOrigScale = this.currScale;
            this.szOrigOffsetOrigin = { left: (this.szTargetOffsetOrigin.left * this.szOrigScale) / this.szTargetScale,
                                        top:  (this.szTargetOffsetOrigin.top  * this.szOrigScale) / this.szTargetScale };
            this.szOrigOffsetViewport = { left: this.szOrigOffsetOrigin.left - currScrollPos.left,
                                          top:  this.szOrigOffsetOrigin.top  - currScrollPos.top };

            this.szCurrentScale = this.szOrigScale;
            this.szCurrentOffsetOrigin = { left: this.szOrigOffsetOrigin.left,
                                           top:  this.szOrigOffsetOrigin.top };
            this.szCurrentOffsetViewport = { left: this.szOrigOffsetViewport.left,
                                             top:  this.szOrigOffsetViewport.top };                

            // ------------------------------------------------------------------------------------
                
            var scrollX = this.szCurrentOffsetOrigin.left - this.szCurrentOffsetViewport.left;
            var scrollY = this.szCurrentOffsetOrigin.top  - this.szCurrentOffsetViewport.top;
                
            this._setDimensions(this.adapter,
                                this.szCurrentScale * this.currPageWidth,
                                this.szCurrentScale * this.currPageHeight);
            this.sceneScroller.scrollTo(-scrollX, -scrollY);
            
            this.adapter.gestureStart(0, 0, 0, 0, 0, 0);
            this.lastZoomRectangle = newZoomRectangle;

						// ------------------------------------------------------------------------------------
						var changesPos = this.szTargetOffsetOrigin.left !== this.szOrigOffsetOrigin.left ||
						this.szTargetOffsetOrigin.top  !== this.szOrigOffsetOrigin.top ||
						this.szTargetOffsetViewport.left !== this.szOrigOffsetViewport.left ||
						this.szTargetOffsetViewport.top  !== this.szOrigOffsetViewport.top;

						var changesScale = Math.abs(newScale - this.currScale) > 0.00001;

						if (changesPos || changesScale) {
							var animDur = changesScale ? 0.5 : 0.2;
							this.controller.window.PalmSystem.runAnimationLoop(this, 
								"_smartZoomAnimationStep",
								"_smartZoomAnimationComplete",
								"easeOut",
								animDur,
								0.0,
								1.0);
							}
						}
						catch (e) {
							Mojo.Log.logException(e, 'smartZoomCalculateResponseSimple');
						}		
					},

	_interpolate: function(a, b, t) {
		return a + t * (b-a);
	},
	
    _smartZoomAnimationStep: function(value) {

        this.szCurrentScale = this._interpolate(this.szOrigScale, this.szTargetScale, value);

        this.szCurrentOffsetViewport.left = Math.round(
				this._interpolate(this.szOrigOffsetViewport.left, this.szTargetOffsetViewport.left, value));
        this.szCurrentOffsetViewport.top  = Math.round(
				this._interpolate(this.szOrigOffsetViewport.top, this.szTargetOffsetViewport.top, value));
       
        this.szCurrentOffsetOrigin.left = Math.round(
				this._interpolate(this.szOrigOffsetOrigin.left, this.szTargetOffsetOrigin.left, value));
        this.szCurrentOffsetOrigin.top  = Math.round(
				this._interpolate(this.szOrigOffsetOrigin.top, this.szTargetOffsetOrigin.top, value));

        var scrollX = this.szCurrentOffsetOrigin.left - this.szCurrentOffsetViewport.left;
        var scrollY = this.szCurrentOffsetOrigin.top  - this.szCurrentOffsetViewport.top;
        
        this._setDimensions(this.adapter,
                            Math.round(this.szCurrentScale * this.currPageWidth),
                            Math.round(this.szCurrentScale * this.currPageHeight));

        this.sceneScroller.scrollTo(-scrollX, -scrollY);

        this.currScale = this.szCurrentScale;            
    },

		_smartZoomAnimationComplete: function() {

			this.adapter.gestureEnd(0, 0, 0, 0, 0, 0);
			this.inPinchZoom = false;

			this._setDimensions(this.adapter,
                           Math.round(this.szTargetScale * this.currPageWidth),
                           Math.round(this.szTargetScale * this.currPageHeight));

      this.sceneScroller.scrollTo(-this.szTargetOffsetOrigin.left,
                                   -this.szTargetOffsetOrigin.top);
      this.currScale = this.szTargetScale;

			if (this.pluginSpotlightOn && this.pluginSpotlightMode == "fullscreen") {
				this._pluginSpotlightCreate(this.lastZoomRectangle, "fullscreen", true);
			} 
 
		if (this._postAnimClickPt) {
			this.adapter.clickAt(this._postAnimClickPt.x * this.currScale,
					this._postAnimClickPt.y * this.currScale, 1);
			delete this._postAnimClickPt;
		}

    },
    
	downloadFinished: function(url, mimeType, tmpFilePath) {

		url = this.$X(url);

        Mojo.Log.info('Download finished');		
		Mojo.Event.send(this.adapter, Mojo.Event.webViewDownloadFinished,
			{url: url, mimeType: mimeType, tmpFilePath:tmpFilePath});	
    },

	/*
	 * Send the response once an Alert has been dismissed
	 */	
	_sendDialogResponse: function(arg1, arg2, arg3) {
		if (arg3) {
			this.adapter.sendDialogResponse(arg1, arg2, arg3);
		}
		else if (arg2) {
			this.adapter.sendDialogResponse(arg1, arg2);
		}
		else {
			this.adapter.sendDialogResponse(arg1);
		}
	},
	
	/**
	 * Called by the adapter when it's time to update the global history
	 * @param {String} url
	 * @param {Boolean} reload
	 */
	updateGlobalHistory: function(url, reload) {

		url = this.$X(url);

		Mojo.Event.send(this.adapter, Mojo.Event.webViewUpdateHistory, 
			{url: url, reload:reload});	
	},
	
	/*
	 * Show a Javascript alert dialog
	 */
	dialogAlert: function(msg) {

		msg = this.$X(msg);

		// Don't display the dialog unless the app is full screen
		if (!this.hasFocus) {
			this._sendDialogResponse("0");
			return;
		}

		var response = function(arg1) {
			try {
				this._sendDialogResponse(arg1);
			}
			catch (e) {
				Mojo.Log.logException(e, 'dialogAlert');
			}
		}.bind(this);
		
		this.controller.scene.showAlertDialog({
			onChoose: function(value) {response("1");},
			message: msg,
			choices:[{label:$LL('OK'), value:'1', type:'dismiss'}]
		});
	},
	
	/*
	 * Show a Javascript confirmation dialog
	 */
	dialogConfirm: function(msg) {

		msg = this.$X(msg);

		// Don't display the dialog unless the app is full screen
		if (!this.hasFocus) {
			this._sendDialogResponse("0");
			return;
		}
	
		var response = function(arg1) {
			try {
				this._sendDialogResponse(arg1);
			}
			catch (e) {
				Mojo.Log.logException(e, 'dialogConfirm');
			}
		}.bind(this);

		this.controller.scene.showAlertDialog({
			onChoose: function(value) {
			if (value) {
				response(value);
			}
			else {
				response("0");
			}},
        	message: msg,
        	choices:[
				{label:$LL('OK'), value:'1', type:'affirmative'},
				{label:$LL('Cancel'), value:'0', type:'dismiss'}]
		});	
	},

	popupChoose: function(value) {
		try {
			this.adapter.selectPopupMenuItem(this.popupMenuId, parseInt(value, 10));
		}
		catch (e) {
			Mojo.Log.logException(e, 'popupChoose');
		}
	},
	
	showPopupMenu: function(menuId, menuObj) {
		try {
			this.popupMenuId = menuId;
			var menuData = menuObj.evalJSON();
			
			var items = [];
			for (var i = 0; i < menuData.items.length; i++) {
				items.push({
					label: menuData.items[i].text,
					command: i.toString(), // FIXME No longer have to convert to string now that NOV-29375 is fixed
					disabled: !menuData.items[i].isEnabled
				});
			}
			
			this.controller.scene.popupSubmenu({
				onChoose:this.popupChoose.bind(this),
				toggleCmd: items[menuData.selectedIdx].command, 
				items: items
			});
		}
		catch (e) {
			Mojo.Log.logException(e, 'showPopupMenu');
		}
	},
	
	hidePopupMenu: function(menuId) {
		// I don't believe that the way we implement popup menus (i.e. they are modal)
		// that we can ever encounter a situation where we are asked to hide a popup
		// menu. Will implement if this turns out to be false. 
	},
	
	/**
	 * Show a Javascript prompt
	 */
	dialogPrompt: function(msg, defaultValue) {
		
		msg = this.$X(msg);
		defaultValue = this.$X(defaultValue);

		// Don't display the dialog unless the app is full screen
		if (!this.hasFocus) {
			this._sendDialogResponse("0");
			return;
		}

		var data = {};
		var response = function(arg1, arg2, arg3) {
			try {
				this._sendDialogResponse(arg1, arg2, arg3);
			}
			catch (e) {
				Mojo.Log.logException(e, 'dialogPrompt');
			}
		}.bind(this);

		// Set up template values
		data.prompt = msg;
		data.value = defaultValue;
		data.template = Mojo.Widget.getSystemTemplatePath('webview/webview-prompt');
		
		// Show the prompt
		data.assistant = new Mojo.Widget.WebView.DialogPromptAssistant(this, data, response);
		this.controller.scene.showDialog(data);
	},
    
	/**
	 * Prompt the user for their username and password
	 */	
	dialogUserPassword: function(msg) {

		msg = this.$X(msg);

		// Don't display the dialog unless the app is full screen
		if (!this.hasFocus) {
			this._sendDialogResponse("0");
			return;
		}

		var data = {};
		var response = function(arg1, arg2, arg3) {
			try {
				this._sendDialogResponse(arg1, arg2, arg3);
			}
			catch (e) {
				Mojo.Log.logException(e, 'dialogUserPassword');
			}
		}.bind(this);
	
		// Set up template values
		data.prompt = msg;
		data.template = Mojo.Widget.getSystemTemplatePath('webview/webview-userpass');
	
		// Show the username & password prompt
		data.assistant = new Mojo.Widget.WebView.DialogUsernamePasswordAssistant(this, data, response);
		this.controller.scene.showDialog(data);
	},
	
	linkClicked : function(url) {

		url = this.$X(url);

		// Take the stored tap event for this tap and send onto our listeners. 
		var tmpEvent = Mojo.Model.decorate(this._lastTapEvent.up, {url: url});
		Mojo.Event.send(this.adapter, Mojo.Event.webViewLinkClicked, tmpEvent);
		delete this._lastTapEvent;
	},
	
	firstPaintComplete: function() {
		Mojo.Event.send(this.adapter, Mojo.Event.webViewFirstPaintComplete, {});
	},
	
	/**
	 * Called by the adapter when the load progress changes.
	 *
	 * @private
	 */
	loadProgress: function(progress) {
        Mojo.Event.send(this.adapter, Mojo.Event.webViewLoadProgress, {'progress': progress});
    },
	
	_saveCurrentPagePosition: function() {
		if (this.lastUrl) {
			Mojo.Log.info("Saving current page position for %s", this.lastUrl);
			var pos = this.sceneScroller.getScrollPosition();
			var dims = this.adapter.getDimensions();
			var item = this.historyInfo[this.lastUrl];
			if (!item) {
				item = new Mojo.WebView.HistoryItem();
				this.historyInfo[this.lastUrl] = item;
			}
			item.scrollX = pos.left;
			item.scrollY = pos.top;
			item.height = dims.height;
			item.width = dims.width;
			item.zoom = this.currScale;
			item.posSet = true;
			this.currentPagePositionSaved = true;
		}
	},
	
	_setDimensions: function(element, width, height) {
		element.style.width = width + 'px';
		element.style.height = height + 'px';
	},
	
	_restoreCurrentPagePosition: function() {
		var url = this.loadingUrl || this.lastUrl;
		if (url) {
			var item = this.historyInfo[url];
			if (item && item.posSet) {

				this.currScale = item.zoom;
			
				this.adapter.setMagnification(item.zoom);

				this._setDimensions(this.adapter, item.width, item.height);

				this.sceneScroller.scrollTo(item.scrollX, item.scrollY);
			}
		}
	},
	
	loadStarted: function() {
		try {

			this.pluginSpotlightRemove();
			
			if (!this.currentPagePositionSaved) {
				this._saveCurrentPagePosition();
			}
			this.currentPagePositionSaved = false;
			this.pageManipulated = false;
			this._lastTapElementInfo = {};
			delete this.metaViewport;
			this.lastUrl = null;	// Don't know the page we're loading until I get a message from the adapter.
			Mojo.Event.send(this.adapter, Mojo.Event.webViewLoadStarted, {});
		} 
		catch (e) {
			Mojo.Log.logException(e, 'loadStarted');
		}
	},
	
	loadStopped: function() {
		try {
			Mojo.Event.send(this.adapter, Mojo.Event.webViewLoadStopped, {});
			this.loadingUrl = null;
			if (!this.pageManipulated) {
				this._restoreCurrentPagePosition();
			}
		}
		catch (e) {
			Mojo.Log.logException(e, 'loadStopped');
		}
    },
	
	didFinishDocumentLoad: function() {
		try {
	        Mojo.Event.send(this.adapter, Mojo.Event.webViewDidFinishDocumentLoad, {});
		}
		catch (e) {
			Mojo.Log.logException(e, 'didFinishDocumentLoad');
		}
    },
	
	failedLoad: function(domain, errorCode, failingURL, localizedMessage) {

		// TODO: Do all these need to be protected, including the errorCode?
		domain = this.$X(domain);
		failingURL = this.$X(failingURL);
		localizedMessage = this.$X(localizedMessage);

        Mojo.Event.send(this.adapter, Mojo.Event.webViewLoadFailed, {domain: domain, errorCode: errorCode,
			failingURL: failingURL, message: localizedMessage});
	},
	
	purgePage: function() {
		Mojo.Log.warn("Have been requested to purge the browser page (%s).", this.lastUrl);
		if (!this.hasFocus) {
			// Adapter will send event to notify us that it's been disconnected.
			this.adapter.disconnectBrowserServer();
		}
	},

	/**
	 * Called when the BrowserServer cannot handle a given URL. This is called when
	 * WebKit cannot support the URL scheme.
	 * 
	 * @param {String} mime The mime type (usually unknown or empty)
	 * @param {String} url The associated URL.
	 */
	mimeNotSupported: function(mime, url) {
		
		url = this.$X(url);

		Mojo.Log.info("Mime not supported: %s (%s)", url, mime);
        Mojo.Event.send(this.adapter, Mojo.Event.webViewMimeNotSupported, {url: url, mimeType: mime});
	},
	
	/**
	 * Called when the BrowserServer cannot (or isn't supposed to) handle a mime type.
	 * Will only be called for the main resource URL.
	 * 
	 * @param {String} mime The mime type.
	 * @param {String} url The associated URL.
	 */
	mimeHandoffUrl: function(mime, url) {
		
		url = this.$X(url);

		Mojo.Log.info("Mime handoff: %s (%s)", url, mime);
        Mojo.Event.send(this.adapter, Mojo.Event.webViewMimeHandoff, {url: url, mimeType: mime});
	},
	
	_setAdapterConnectionState: function(connected) {
		this.adapterConnected = connected;
		if (connected) {
			if (this._serverConnectTimer !== undefined) {
				this.controller.window.clearTimeout(this._serverConnectTimer);
				delete this._serverConnectTimer;
			}
		}
		else {
			if (this._serverConnectTimer === undefined) {
				this._serverConnectTimer = this.controller.window.setTimeout(this._connectAdapterToServer, 3000);
			}
			
			this._removeElementHighlight();
		}
	},
	
	_connectAdapterToServer: function() {
	
		try {
			delete this._serverConnectTimer;
			this.adapter.connectBrowserServer();
			this._setAdapterConnectionState(true);
			
			Mojo.Event.send(this.adapter, Mojo.Event.webViewServerConnect, {});
		}
		catch (e) {
			this._setAdapterConnectionState(false);
		}
	},

	browserServerDisconnected: function() {
		try {
			Mojo.Log.error("Disconnected from BrowserServer.");
			if (this.hasFocus) {
				// Only the foreground widget will try to reconnect.
				this._setAdapterConnectionState(false);
			}
			else {
				// else set state try again once the application is brought to the foreground.
				this.adapterConnected = false;
			}
			Mojo.Event.send(this.adapter, Mojo.Event.webViewServerDisconnect, {});
		}
		catch (e) {
			Mojo.Log.logException(e, 'browserServerDisconnected');
		}
	},
	
	setMainDocumentError: function(domain, errorCode, failingURL, localizedMessage) {

		// TODO: Do all these need to be protected, including the errorCode?
		domain = this.$X(domain);
		failingURL = this.$X(failingURL);
		localizedMessage = this.$X(localizedMessage);

        Mojo.Event.send(this.adapter, Mojo.Event.webViewSetMainDocumentError, {domain: domain, errorCode: errorCode,
			failingURL: failingURL, message: localizedMessage});
	},

	editorFocused: function(focused, fieldtype, fieldactions) {
		if (this.controller.window.PalmSystem.editorFocused) {
			this.controller.window.PalmSystem.editorFocused(focused, fieldtype, fieldactions);
		}
        Mojo.Event.send(this.adapter, Mojo.Event.webViewEditorFocused, {focused: focused});
	},
	
	reportError: function(url, code, message) {

		url = this.$X(url);
		message = this.$X(message);

		Mojo.Log.error("Error %d on page: '%s', msg: '%s'", code, url, message);
		// How best to report this to our client.
	},
	
	createPage: function(pageIdentifier) {
	    Mojo.Event.send(this.adapter, Mojo.Event.webViewCreatePage, {'pageIdentifier': pageIdentifier});
	},

	clickRejected: function(tapIndex) {
		delete this._lastTapEvent;
		if (tapIndex >= this.tapIndex) {
			Mojo.Event.send(this.adapter, Mojo.Event.webViewTapRejected, {});
		}
	},

	/**
	 * Called after the browser adapter is successfully initialized.
	 */
	adapterInitialized: function() {
		Mojo.Log.info("Browser adapter initialized.");
		try {
            // NOTE ** no BrowserAdapter calls before this.adapter.setPageIdentifier
	        // setPageIdentifier *needs* to be the first adapter call
	        // Otherwise, the default identifier, -1, will be used in the case
	        // when the BrowserAdapter needs to pair with an existing
	        // BrowserPage on the BS side, which will result in a leaked BP
	        // and a blank page.
	        if (this.controller.attributes.pageIdentifier !== undefined) {
	            this.adapter.setPageIdentifier(this.controller.attributes.pageIdentifier);
	        }
	        else if (this.controller.attributes.url !== undefined) {
	            this.openURL(this.controller.attributes.url);
	        }
	        if (this.controller.attributes.minFontSize !== undefined) {
	            this.adapter.setMinFontSize(this.controller.attributes.minFontSize);
	        }
	        
			if (this.controller.attributes.interrogateClicks) {
				this.adapter.interrogateClicks(true);
			}

			if (this.controller.attributes.showClickedLink !== undefined) {
			    this.adapter.setShowClickedLink(this.controller.attributes.showClickedLink);
			}
			
	        this.adapter.setViewportSize(this.controller.window.innerWidth, this.controller.attributes.virtualpageheight);
		}
		catch (e) {
			Mojo.Log.logException(e, 'adapterInitialized');
		}
	},
	
	/*
	 * @deprecated Not supported in v1.0 or later.
	 */
	registerOnPopup: function(callback) {
		
		this.popupCallbacks.push(callback);
	},
	
	/*
	 * @deprecated Not supported in v1.0 or later.
	 */
	unregisterOnPopup: function(callback) {
		
		var idx = this.popupCallbacks.indexOf(callback);
		if (idx >= 0) {
			this.popupCallbacks[idx] = null;
			this.popupCallbacks = this.popupCallbacks.compact();
		}
	},
	
	focus: function() {
	    this.adapter.focus();
	},
	
	blur: function() {
	    this.adapter.blur();
	},
	
	setShowClickedLink: function(enable) {
	    if (this.useAdapter) {
		this.adapter.setShowClickedLink(enable);
	    }
	},

	/**
	 * Show a Certificate warning prompt
	 */
	dialogSSLConfirm: function(host,code) {

		host = this.$X(host);
				
		// If we don't have focus then do not display the dialog and auto respond.
		if (!this.hasFocus) {
			this._sendDialogResponse('0');
			return;
		}
		
		var response = function(result) {
			
			try {
				this._sendDialogResponse(result);
			} catch (e) {
				Mojo.Log.logException(e, 'dialogCertificateWarning()');	
			}
		}.bind(this);

		// Show the certificate dialog
		this.controller.scene.showDialog({
			certReason: Mojo.Widget.WebView.CertificateErrors.getCertificateErrorString({code: code, websiteName: host}),
			template: Mojo.Widget.getSystemTemplatePath('webview/certwarn-dialog'),
			assistant: new Mojo.WebView.CertificateWarningAssistant(this.controller, response)
		});
	},
	
	/**
	 * Signal the status of an image save.
	*/
	imageSaved: function(status, filepath) {
		
		Mojo.Event.send(this.adapter, Mojo.Event.webViewImageSaved, {'status': status, 'filepath':filepath});
	}
});


/**
 * Certificate Warning dialog
 */
Mojo.WebView.CertificateWarningAssistant = Class.create({
	
	initialize: function(controller, sendResponse) {

		this._sendResponse = sendResponse;
		this.controller = controller;
		this._certTrustHandler     = this._certTrust.bindAsEventListener(this);
		this._certTrustOnceHandler = this._certTrustOnce.bindAsEventListener(this);
		this._certTrustDontHandler = this._certTrustDont.bindAsEventListener(this);
	},
			
	setup: function(widget) {
		
		this.widget = widget;
	},

	activate: function() {

		// Listen for button taps
		Mojo.Event.listen(this.controller.get('cert_trust_button'), Mojo.Event.tap, this._certTrustHandler);
		Mojo.Event.listen(this.controller.get('cert_trustonce_button'), Mojo.Event.tap, this._certTrustOnceHandler);
		Mojo.Event.listen(this.controller.get('cert_trustdont_button'), Mojo.Event.tap, this._certTrustDontHandler);
	},
	
	deactivate: function() {

		Mojo.Event.stopListening(this.controller.get('cert_trust_button'), Mojo.Event.tap, this._certTrustHandler);
		Mojo.Event.stopListening(this.controller.get('cert_trustonce_button'), Mojo.Event.tap, this._certTrustOnceHandler);
		Mojo.Event.stopListening(this.controller.get('cert_trustdont_button'), Mojo.Event.tap, this._certTrustDontHandler);		
	},

	cleanup: function() {

		// If we are closed by any other method than a button press then
		// send a 'don't trust' response.
		if (this._sendResponse) {
			this._sendResponse('0');
		}
	},
	
	_certTrust: function() {
		
		this._sendResponse('1');
		delete this._sendResponse;
		// Close the dialog box
		this.widget.mojo.close();
	},
	
	_certTrustOnce: function() {
		
		this._sendResponse('2');		
		delete this._sendResponse;
		// Close the dialog box
		this.widget.mojo.close();
	},
	
	_certTrustDont: function() {
		
		this._sendResponse('0');
		delete this._sendResponse;
		// Close the dialog box
		this.widget.mojo.close();		
	}
});

/**
 * Assistant for the username/password dialog
 */
Mojo.Widget.WebView.DialogUsernamePasswordAssistant = Class.create({

	initialize: function(widgetController, data, sendCb) {
		this.data = data;
		this.sendCb = sendCb;
		this.controller = widgetController.controller;
		this.okButtonHandler = this.handleOkayButton.bindAsEventListener(this);
		this.cancelHandler = this.handleCancelButton.bindAsEventListener(this);
	},

	setup : function(widget) {

		this.widget = widget;

		this.usernameAttr = {
			hintText: $LL('Enter username...'),
			multiline: false,
			focus: true,
			textReplacement: false,
			changeOnKeyPress: true,
			focusMode: Mojo.Widget.focusSelectMode,	
			acceptBack: true
		};

		this.usernameModel = {
			value: '',
			disabled: false
		};

		this.passwordAttr = {
			hintText: $LL('Enter password...'),
			multiline: false,
			focus: false,
			textReplacement: false,
			changeOnKeyPress: true,
			focusMode: Mojo.Widget.focusSelectMode,	
			acceptBack: true
		};

		this.passwordModel = {
			value: '',
			disabled: false
		};

		this._passField = this.controller.scene.setupWidget('password', this.passwordAttr, this.passwordModel);
		this._userField = this.controller.scene.setupWidget('username', this.usernameAttr, this.usernameModel);

	},

	activate: function() {	

		// Listen for button taps
		Mojo.Event.listen(this.controller.get('webViewDialogOkayButton'), Mojo.Event.tap, this.okButtonHandler);
		Mojo.Event.listen(this.controller.get('webViewDialogCancelButton'), Mojo.Event.tap, this.cancelHandler);
	},

	deactivate: function() {

		Mojo.Event.stopListening(this.controller.get('webViewDialogOkayButton'), Mojo.Event.tap, this.okButtonHandler);
		Mojo.Event.stopListening(this.controller.get('webViewDialogCancelButton'), Mojo.Event.tap, this.cancelHandler);
	},

	handleOkayButton: function() {

		var str = this.usernameModel.value; 
		var pwd = this.passwordModel.value; 

		// Call the callback now
		this.sendCb("1", str, pwd);

		// Clear the callback so it isn't called by the cleanup routine
		delete this.sendCb;

		// Close the dialog box
		this.widget.mojo.close();
	},

	handleCancelButton: function() {

		// Send "Cancel"
		this.sendCb('0');

		// Clear the callback so it isn't called by the cleanup routine
		delete this.sendCb;

		// Close the dialog box
		this.widget.mojo.close();
	},

	cleanup: function() {

		// Send "Cancel" if necessary
		if (this.sendCb) {
			this.sendCb('0');
		}
	}
});

/**
 * Assistant for the prompt dialog
 */
Mojo.Widget.WebView.DialogPromptAssistant = Class.create({
	
	initialize: function(widgetController, data, sendCb) {
		this.data = data;
		this.sendCb = sendCb;
		this.controller = widgetController.controller;
		this.okButtonHandler = this.handleOkayButton.bindAsEventListener(this);
		this.cancelHandler = this.handleCancelButton.bindAsEventListener(this);
	},

	setup : function(widget) {

		this.widget = widget;

		this.userPromptAttr = {
			multiline: false,
			focus: true,
			textReplacement: false,
			changeOnKeyPress: true,
			focusMode: Mojo.Widget.focusSelectMode,	
			acceptBack: true
		};

		this.userPromptModel = {
			value: this.data.value,
			disabled: false
		};

		this._userPrompt = this.controller.scene.setupWidget('userprompt', this.userPromptAttr, this.userPromptModel);
	},

	activate: function() {
		
		// Listen for button taps
		Mojo.Event.listen(this.controller.get('webViewDialogOkayButton'), Mojo.Event.tap, this.okButtonHandler);
		Mojo.Event.listen(this.controller.get('webViewDialogCancelButton'), Mojo.Event.tap, this.cancelHandler);
	},

	deactivate: function() {

		Mojo.Event.stopListening(this.controller.get('webViewDialogOkayButton'), Mojo.Event.tap, this.okButtonHandler);
		Mojo.Event.stopListening(this.controller.get('webViewDialogCancelButton'), Mojo.Event.tap, this.cancelHandler);
	},

	handleOkayButton: function() {

		var str = this.userPromptModel.value; 
		// Call the callback now
		this.sendCb("1", str);

		// Clear the callback so it isn't called by the cleanup routine
		delete this.sendCb;

		// Close the dialog box
		this.widget.mojo.close();
	},

	handleCancelButton: function() {

		// Send "Cancel"
		this.sendCb('0');

		// Clear the callback so it isn't called by the cleanup routine
		delete this.sendCb;

		// Close the dialog box
		this.widget.mojo.close();
	},

	cleanup: function() {
		
		// Send "Cancel" if necessary
		if (this.sendCb) {
			this.sendCb('0');
		}
	}
});

Mojo.Widget.WebView.CertificateErrors = function() {
	
	var codes = {
		'0': $LL("The security certificate #{websiteName} sent is expired. Connecting to this site might put your confidential information at risk."),
		'2': $LL("The website #{websiteName} didn't send a security certificate to identify itself. Connecting to this site might put your confidential information at risk."),
		'5': $LL("The security certificate #{websiteName} sent could not be read completely. Connecting to this site might put your confidential information at risk."),
		'10': $LL("The security certificate #{websiteName} sent has some invalid information. Connecting to this site might put your confidential information at risk."),
		'18': $LL("The security certificate #{websiteName} sent has questionable signatures. Connecting to this site might put your confidential information at risk."),
		'24': $LL("The security certificate #{websiteName} sent is invalid. Connecting to this site might put your confidential information at risk."),
		'30': $LL("The security certificate #{websiteName} sent has inconsistent information in it. Connecting to this site might put your confidential information at risk.")
	};
	
	var table = $H();
	table.set('0', codes['0']);
	
	table.set('2', codes['2']);
	table.set('3', codes['2']);
	table.set('4', codes['2']);
	
	table.set('5', codes['5']);
	table.set('6', codes['5']);
	table.set('7', codes['5']);
	table.set('8', codes['5']);
	table.set('9', codes['5']);
	
	table.set('10', codes['10']);
	table.set('11', codes['10']);
	table.set('12', codes['10']);
	table.set('13', codes['10']);
	table.set('14', codes['10']);
	table.set('15', codes['10']);
	table.set('16', codes['10']);
	table.set('17', codes['10']);
	
	table.set('18', codes['18']);
	table.set('19', codes['18']);
	table.set('20', codes['18']);
	table.set('21', codes['18']);
	table.set('22', codes['18']);
	table.set('23', codes['18']);
	
	table.set('24', codes['24']);
	table.set('25', codes['24']);
	table.set('26', codes['24']);
	table.set('27', codes['24']);
	table.set('28', codes['24']);
	table.set('29', codes['24']);
	
	table.set('30', codes['30']);
	table.set('31', codes['30']);
	table.set('50', codes['30']);
	
	return {
		getCertificateErrorString: function(model){
			if (model.code !== undefined) {
				var templateString = table.get(model.code.toString());
				if (templateString) {
					var template = new Template(templateString);
					return template.evaluate(model);
				}
			}
		}
	};
}();
